// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlclient

import (
	"fmt"
	"io"
	"strconv"
)

// supported kubernetes objects fetchable in runbooks
type KubernetesData interface {
	IsKubernetesData()
}

type AccessToken struct {
	ID         *string                     `json:"id"`
	Token      *string                     `json:"token"`
	Audits     *AccessTokenAuditConnection `json:"audits"`
	InsertedAt *string                     `json:"insertedAt"`
	UpdatedAt  *string                     `json:"updatedAt"`
}

type AccessTokenAudit struct {
	ID         *string `json:"id"`
	IP         *string `json:"ip"`
	Timestamp  *string `json:"timestamp"`
	Count      *int64  `json:"count"`
	City       *string `json:"city"`
	Country    *string `json:"country"`
	Latitude   *string `json:"latitude"`
	Longitude  *string `json:"longitude"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type AccessTokenAuditConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*AccessTokenAuditEdge `json:"edges"`
}

type AccessTokenAuditEdge struct {
	Node   *AccessTokenAudit `json:"node"`
	Cursor *string           `json:"cursor"`
}

type AccessTokenConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*AccessTokenEdge `json:"edges"`
}

type AccessTokenEdge struct {
	Node   *AccessToken `json:"node"`
	Cursor *string      `json:"cursor"`
}

type Account struct {
	DelinquentAt       *string             `json:"delinquentAt"`
	GrandfatheredUntil *string             `json:"grandfatheredUntil"`
	AvailableFeatures  *AvailableFeatures  `json:"availableFeatures"`
	Subscription       *PluralSubscription `json:"subscription"`
}

// a condition that determines whether its configuration is viewable
type AddOnConfigCondition struct {
	// the operation for this condition, eg EQ, LT, GT
	Operation *string `json:"operation"`
	// the field this condition applies to
	Field *string `json:"field"`
	// the value to apply the condition with, for binary operators like LT/GT
	Value *string `json:"value"`
}

// Input configuration for an add-on you can install
type AddOnConfiguration struct {
	// name for this configuration
	Name *string `json:"name"`
	// a docstring explaining this configuration
	Documentation *string `json:"documentation"`
	// a type for the configuration (should eventually be coerced back to string)
	Type *string `json:"type"`
	// the values for ENUM type conditions
	Values    []*string             `json:"values"`
	Condition *AddOnConfigCondition `json:"condition"`
}

// the specification of a runtime service at a specific version
type AddonVersion struct {
	// add-on version, semver formatted
	Version *string `json:"version"`
	// kubernetes versions this add-on works with
	Kube []*string `json:"kube"`
	// any other add-ons this might require
	Requirements []*VersionReference `json:"requirements"`
	// any add-ons this might break
	Incompatibilities []*VersionReference `json:"incompatibilities"`
	// checks if this is blocking a specific kubernetes upgrade
	Blocking *bool `json:"blocking"`
}

// a representation of a kubernetes api deprecation
type APIDeprecation struct {
	// the kubernetes version the deprecation was posted
	DeprecatedIn *string `json:"deprecatedIn"`
	// the kubernetes version the api version will be removed and unusable in
	RemovedIn *string `json:"removedIn"`
	// the api you can replace this resource with
	Replacement *string `json:"replacement"`
	// the kubernetes version the replacement api was created in
	AvailableIn *string `json:"availableIn"`
	// whether you cannot safely upgrade to the next kubernetes version if this deprecation exists
	Blocking *bool `json:"blocking"`
	// the component of this deprecation
	Component *ServiceComponent `json:"component"`
}

type Application struct {
	Name          string            `json:"name"`
	Spec          ApplicationSpec   `json:"spec"`
	Status        ApplicationStatus `json:"status"`
	Cost          *CostAnalysis     `json:"cost"`
	License       *License          `json:"license"`
	Configuration *Configuration    `json:"configuration"`
	Info          *string           `json:"info"`
}

type ApplicationDelta struct {
	Delta   *Delta       `json:"delta"`
	Payload *Application `json:"payload"`
}

type ApplicationDescriptor struct {
	Type        string             `json:"type"`
	Version     string             `json:"version"`
	Description *string            `json:"description"`
	Icons       []*string          `json:"icons"`
	Links       []*ApplicationLink `json:"links"`
}

type ApplicationInfoItem struct {
	Type  *string `json:"type"`
	Name  *string `json:"name"`
	Value *string `json:"value"`
}

type ApplicationLink struct {
	URL         *string `json:"url"`
	Description *string `json:"description"`
}

type ApplicationSpec struct {
	Descriptor ApplicationDescriptor  `json:"descriptor"`
	Components []*Component           `json:"components"`
	Info       []*ApplicationInfoItem `json:"info"`
}

type ApplicationStatus struct {
	Components      []*StatusComponent `json:"components"`
	Conditions      []*StatusCondition `json:"conditions"`
	ComponentsReady string             `json:"componentsReady"`
}

type Audit struct {
	ID         string      `json:"id"`
	Action     AuditAction `json:"action"`
	Type       AuditType   `json:"type"`
	Repository *string     `json:"repository"`
	IP         *string     `json:"ip"`
	City       *string     `json:"city"`
	Country    *string     `json:"country"`
	Latitude   *string     `json:"latitude"`
	Longitude  *string     `json:"longitude"`
	Actor      *User       `json:"actor"`
	InsertedAt *string     `json:"insertedAt"`
	UpdatedAt  *string     `json:"updatedAt"`
}

type AuditConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AuditEdge `json:"edges"`
}

type AuditEdge struct {
	Node   *Audit  `json:"node"`
	Cursor *string `json:"cursor"`
}

type AuditMetric struct {
	Country *string `json:"country"`
	Count   *int64  `json:"count"`
}

type AvailableFeatures struct {
	Vpn                *bool `json:"vpn"`
	Audits             *bool `json:"audits"`
	Cd                 *bool `json:"cd"`
	UserManagement     *bool `json:"userManagement"`
	DatabaseManagement *bool `json:"databaseManagement"`
}

// aws node customizations
type AwsCloud struct {
	// custom launch template for your nodes, useful for Golden AMI setups
	LaunchTemplateID *string `json:"launchTemplateId"`
}

type AwsCloudAttributes struct {
	Region *string `json:"region,omitempty"`
}

type AwsSettingsAttributes struct {
	AccessKeyID     string `json:"accessKeyId"`
	SecretAccessKey string `json:"secretAccessKey"`
}

type AzureCloudAttributes struct {
	Location       *string `json:"location,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	ResourceGroup  *string `json:"resourceGroup,omitempty"`
	Network        *string `json:"network,omitempty"`
}

type AzureSettingsAttributes struct {
	TenantID       string `json:"tenantId"`
	SubscriptionID string `json:"subscriptionId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

type BindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

type Build struct {
	ID          string             `json:"id"`
	Repository  string             `json:"repository"`
	Type        BuildType          `json:"type"`
	Status      Status             `json:"status"`
	Message     *string            `json:"message"`
	CompletedAt *string            `json:"completedAt"`
	Sha         *string            `json:"sha"`
	Commands    *CommandConnection `json:"commands"`
	Creator     *User              `json:"creator"`
	Approver    *User              `json:"approver"`
	Changelogs  []*Changelog       `json:"changelogs"`
	InsertedAt  *string            `json:"insertedAt"`
	UpdatedAt   *string            `json:"updatedAt"`
}

type BuildAttributes struct {
	Repository string     `json:"repository"`
	Type       *BuildType `json:"type,omitempty"`
	Message    *string    `json:"message,omitempty"`
}

type BuildConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*BuildEdge `json:"edges"`
}

type BuildDelta struct {
	Delta   *Delta `json:"delta"`
	Payload *Build `json:"payload"`
}

type BuildEdge struct {
	Node   *Build  `json:"node"`
	Cursor *string `json:"cursor"`
}

type BuildInfo struct {
	All        *int64 `json:"all"`
	Failed     *int64 `json:"failed"`
	Queued     *int64 `json:"queued"`
	Running    *int64 `json:"running"`
	Successful *int64 `json:"successful"`
}

type Certificate struct {
	Metadata Metadata          `json:"metadata"`
	Status   CertificateStatus `json:"status"`
	Spec     CertificateSpec   `json:"spec"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events"`
}

type CertificateSpec struct {
	DNSNames   []*string  `json:"dnsNames"`
	SecretName string     `json:"secretName"`
	IssuerRef  *IssuerRef `json:"issuerRef"`
}

type CertificateStatus struct {
	Conditions  []*StatusCondition `json:"conditions"`
	NotAfter    *string            `json:"notAfter"`
	NotBefore   *string            `json:"notBefore"`
	RenewalTime *string            `json:"renewalTime"`
}

type Changelog struct {
	ID         string  `json:"id"`
	Repo       string  `json:"repo"`
	Tool       string  `json:"tool"`
	Content    *string `json:"content"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type CloneAttributes struct {
	S3AccessKeyID     *string `json:"s3AccessKeyId,omitempty"`
	S3SecretAccessKey *string `json:"s3SecretAccessKey,omitempty"`
	S3WalPath         *string `json:"s3WalPath,omitempty"`
	S3Endpoint        *string `json:"s3Endpoint,omitempty"`
	UID               *string `json:"uid,omitempty"`
}

type CloudProviderSettingsAttributes struct {
	Aws   *AwsSettingsAttributes   `json:"aws,omitempty"`
	Gcp   *GcpSettingsAttributes   `json:"gcp,omitempty"`
	Azure *AzureSettingsAttributes `json:"azure,omitempty"`
}

// cloud specific settings for a node pool
type CloudSettings struct {
	Aws *AwsCloud `json:"aws"`
}

type CloudSettingsAttributes struct {
	Aws   *AwsCloudAttributes   `json:"aws,omitempty"`
	Gcp   *GcpCloudAttributes   `json:"gcp,omitempty"`
	Azure *AzureCloudAttributes `json:"azure,omitempty"`
}

// a representation of a cluster you can deploy to
type Cluster struct {
	// internal id of this cluster
	ID string `json:"id"`
	// whether this is the management cluster itself
	Self *bool `json:"self"`
	// human readable name of this cluster, will also translate to cloud k8s name
	Name string `json:"name"`
	// if true, this cluster cannot be deleted
	Protect *bool `json:"protect"`
	// desired k8s version for the cluster
	Version *string `json:"version"`
	// current k8s version as told to us by the deployment operator
	CurrentVersion *string `json:"currentVersion"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle"`
	// whether the deploy operator has been registered for this cluster
	Installed *bool `json:"installed"`
	// the url of the kas server you can access this cluster from
	KasURL *string `json:"kasUrl"`
	// a auth token to be used by the deploy operator, only readable on create
	DeployToken *string `json:"deployToken"`
	// when this cluster was scheduled for deletion
	DeletedAt *string `json:"deletedAt"`
	// last time the deploy operator pinged this cluster
	PingedAt *string `json:"pingedAt"`
	// read policy for this cluster
	ReadBindings []*PolicyBinding `json:"readBindings"`
	// write policy for this cluster
	WriteBindings []*PolicyBinding `json:"writeBindings"`
	// list of node pool specs managed by CAPI
	NodePools []*NodePool `json:"nodePools"`
	// the provider we use to create this cluster (null if BYOK)
	Provider *ClusterProvider `json:"provider"`
	// a custom credential to use when provisioning this cluster
	Credential *ProviderCredential `json:"credential"`
	// the service used to deploy the CAPI resources of this cluster
	Service *ServiceDeployment `json:"service"`
	// key/value tags to filter clusters
	Tags []*Tag `json:"tags"`
	// all api deprecations for all services in this cluster
	APIDeprecations []*APIDeprecation `json:"apiDeprecations"`
	// any errors which might have occurred during the bootstrap process
	ServiceErrors []*ServiceError `json:"serviceErrors"`
	// a custom git repository if you want to define your own CAPI manifests
	Repository *GitRepository `json:"repository"`
	// list cached nodes for a cluster, this can be stale up to 5m
	Nodes []*Node `json:"nodes"`
	// list the cached node metrics for a cluster, can also be stale up to 5m
	NodeMetrics []*NodeMetric `json:"nodeMetrics"`
	// the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null
	Status *ClusterStatus `json:"status"`
	// a relay connection of all revisions of this service, these are periodically pruned up to a history limit
	Revisions *RevisionConnection `json:"revisions"`
	// fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries
	RuntimeServices []*RuntimeService `json:"runtimeServices"`
	// whether the current user can edit this cluster
	Editable   *bool   `json:"editable"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

// A common kubernetes cluster add-on like cert-manager, istio, etc
type ClusterAddOn struct {
	Name          *string               `json:"name"`
	Version       *string               `json:"version"`
	Icon          *string               `json:"icon"`
	Global        *bool                 `json:"global"`
	Configuration []*AddOnConfiguration `json:"configuration"`
}

type ClusterAttributes struct {
	Name string `json:"name"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle     *string `json:"handle,omitempty"`
	ProviderID *string `json:"providerId,omitempty"`
	// a cloud credential to use when provisioning this cluster
	CredentialID  *string                    `json:"credentialId,omitempty"`
	Version       *string                    `json:"version,omitempty"`
	Protect       *bool                      `json:"protect,omitempty"`
	Kubeconfig    *KubeconfigAttributes      `json:"kubeconfig,omitempty"`
	CloudSettings *CloudSettingsAttributes   `json:"cloudSettings,omitempty"`
	NodePools     []*NodePoolAttributes      `json:"nodePools,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	Tags          []*TagAttributes           `json:"tags,omitempty"`
}

// a single condition struct for various phases of the cluster provisionining process
type ClusterCondition struct {
	LastTransitionTime *string `json:"lastTransitionTime"`
	Status             *string `json:"status"`
	Type               *string `json:"type"`
	Message            *string `json:"message"`
	Reason             *string `json:"reason"`
	Severity           *string `json:"severity"`
}

type ClusterConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*ClusterEdge `json:"edges"`
}

type ClusterEdge struct {
	Node   *Cluster `json:"node"`
	Cursor *string  `json:"cursor"`
}

type ClusterInfo struct {
	GitCommit  *string `json:"gitCommit"`
	GitVersion *string `json:"gitVersion"`
	Platform   *string `json:"platform"`
	Version    *string `json:"version"`
}

type ClusterPing struct {
	CurrentVersion string `json:"currentVersion"`
}

// a CAPI provider for a cluster, cloud is inferred from name if not provided manually
type ClusterProvider struct {
	// the id of this provider
	ID string `json:"id"`
	// a human readable name for the provider, globally unique
	Name string `json:"name"`
	// the namespace the CAPI resources are deployed into
	Namespace string `json:"namespace"`
	// the name of the cloud service for this provider
	Cloud string `json:"cloud"`
	// the details of how cluster manifests will be synced from git when created with this provider
	Git GitRef `json:"git"`
	// the repository used to serve cluster manifests
	Repository *GitRepository `json:"repository"`
	// the repository for the CAPI service itself if customized
	ProviderRepository *GitRepository `json:"providerRepository"`
	// the service of the CAPI controller itself
	Service *ServiceDeployment `json:"service"`
	// a list of credentials eligible for this provider
	Credentials []*ProviderCredential `json:"credentials"`
	// when the cluster provider was deleted
	DeletedAt       *string           `json:"deletedAt"`
	RuntimeServices []*RuntimeService `json:"runtimeServices"`
	// the kubernetes versions this provider currently supports
	SupportedVersions []*string `json:"supportedVersions"`
	// the region names this provider can deploy to
	Regions []*string `json:"regions"`
	// whether the current user can edit this resource
	Editable   *bool   `json:"editable"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type ClusterProviderAttributes struct {
	Name          string                           `json:"name"`
	Namespace     *string                          `json:"namespace,omitempty"`
	Cloud         *string                          `json:"cloud,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterProviderConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterProviderEdge `json:"edges"`
}

type ClusterProviderEdge struct {
	Node   *ClusterProvider `json:"node"`
	Cursor *string          `json:"cursor"`
}

type ClusterProviderUpdateAttributes struct {
	// if you optionally want to reconfigure the git repository for the cluster provider
	Service       *ClusterServiceAttributes        `json:"service,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterServiceAttributes struct {
	ID           string           `json:"id"`
	RepositoryID *string          `json:"repositoryId,omitempty"`
	Git          GitRefAttributes `json:"git"`
}

// the crd status of the cluster as seen by the CAPI operator
type ClusterStatus struct {
	Phase             *string             `json:"phase"`
	ControlPlaneReady *bool               `json:"controlPlaneReady"`
	FailureMessage    *string             `json:"failureMessage"`
	FailureReason     *string             `json:"failureReason"`
	Conditions        []*ClusterCondition `json:"conditions"`
}

type ClusterUpdateAttributes struct {
	Version *string `json:"version,omitempty"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle,omitempty"`
	// if you optionally want to reconfigure the git repository for the cluster service
	Service    *ClusterServiceAttributes `json:"service,omitempty"`
	Kubeconfig *KubeconfigAttributes     `json:"kubeconfig,omitempty"`
	Protect    *bool                     `json:"protect,omitempty"`
	NodePools  []*NodePoolAttributes     `json:"nodePools,omitempty"`
}

type Command struct {
	ID          string  `json:"id"`
	Command     string  `json:"command"`
	ExitCode    *int64  `json:"exitCode"`
	Stdout      *string `json:"stdout"`
	CompletedAt *string `json:"completedAt"`
	Build       *Build  `json:"build"`
	InsertedAt  *string `json:"insertedAt"`
	UpdatedAt   *string `json:"updatedAt"`
}

type CommandConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*CommandEdge `json:"edges"`
}

type CommandDelta struct {
	Delta   *Delta   `json:"delta"`
	Payload *Command `json:"payload"`
}

type CommandEdge struct {
	Node   *Command `json:"node"`
	Cursor *string  `json:"cursor"`
}

type Component struct {
	Group string `json:"group"`
	Kind  string `json:"kind"`
}

type ComponentAttributes struct {
	State     *ComponentState `json:"state,omitempty"`
	Synced    bool            `json:"synced"`
	Group     string          `json:"group"`
	Version   string          `json:"version"`
	Kind      string          `json:"kind"`
	Namespace string          `json:"namespace"`
	Name      string          `json:"name"`
}

type ConfigAttributes struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

type ConfigMap struct {
	Metadata Metadata               `json:"metadata"`
	Data     map[string]interface{} `json:"data"`
	Raw      string                 `json:"raw"`
}

type Configuration struct {
	Terraform *string `json:"terraform"`
	Helm      *string `json:"helm"`
	Readme    *string `json:"readme"`
}

type ConfigurationAction struct {
	Updates []*PathUpdate `json:"updates"`
}

type ConfigurationCondition struct {
	Field     *string `json:"field"`
	Value     *string `json:"value"`
	Operation *string `json:"operation"`
}

type ConfigurationItem struct {
	Name          *string                  `json:"name"`
	Type          *string                  `json:"type"`
	Placeholder   *string                  `json:"placeholder"`
	Documentation *string                  `json:"documentation"`
	Default       *string                  `json:"default"`
	Optional      *bool                    `json:"optional"`
	Condition     *ConfigurationCondition  `json:"condition"`
	Validation    *ConfigurationValidation `json:"validation"`
}

type ConfigurationOverlay struct {
	Metadata Metadata                 `json:"metadata"`
	Spec     ConfigurationOverlaySpec `json:"spec"`
}

type ConfigurationOverlaySpec struct {
	Name          *string          `json:"name"`
	Folder        *string          `json:"folder"`
	Subfolder     *string          `json:"subfolder"`
	Documentation *string          `json:"documentation"`
	Updates       []*OverlayUpdate `json:"updates"`
	InputType     *string          `json:"inputType"`
	InputValues   []*string        `json:"inputValues"`
}

type ConfigurationValidation struct {
	Type    *string `json:"type"`
	Regex   *string `json:"regex"`
	Message *string `json:"message"`
}

type ConsoleConfiguration struct {
	GitCommit     *string            `json:"gitCommit"`
	IsDemoProject *bool              `json:"isDemoProject"`
	IsSandbox     *bool              `json:"isSandbox"`
	PluralLogin   *bool              `json:"pluralLogin"`
	VpnEnabled    *bool              `json:"vpnEnabled"`
	Byok          *bool              `json:"byok"`
	Features      *AvailableFeatures `json:"features"`
	Manifest      *PluralManifest    `json:"manifest"`
	GitStatus     *GitStatus         `json:"gitStatus"`
}

type Container struct {
	Image     *string    `json:"image"`
	Name      *string    `json:"name"`
	Ports     []*Port    `json:"ports"`
	Resources *Resources `json:"resources"`
}

// the attributes for a container
type ContainerAttributes struct {
	Image   string               `json:"image"`
	Args    []*string            `json:"args,omitempty"`
	Env     []*EnvAttributes     `json:"env,omitempty"`
	EnvFrom []*EnvFromAttributes `json:"envFrom,omitempty"`
}

// container env variable
type ContainerEnv struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// env from declarations for containers
type ContainerEnvFrom struct {
	ConfigMap string `json:"configMap"`
	Secret    string `json:"secret"`
}

type ContainerRecommendation struct {
	Name           *string             `json:"name"`
	ContainerName  *string             `json:"containerName"`
	Target         *ContainerResources `json:"target"`
	LowerBound     *ContainerResources `json:"lowerBound"`
	UpperBound     *ContainerResources `json:"upperBound"`
	UncappedTarget *ContainerResources `json:"uncappedTarget"`
}

type ContainerResources struct {
	CPU    *string `json:"cpu"`
	Memory *string `json:"memory"`
}

// a shortform spec for job containers, designed for ease-of-use
type ContainerSpec struct {
	Image   string              `json:"image"`
	Args    []*string           `json:"args"`
	Env     []*ContainerEnv     `json:"env"`
	EnvFrom []*ContainerEnvFrom `json:"envFrom"`
}

type ContainerState struct {
	Running    *RunningState    `json:"running"`
	Terminated *TerminatedState `json:"terminated"`
	Waiting    *WaitingState    `json:"waiting"`
}

type ContainerStatus struct {
	RestartCount *int64          `json:"restartCount"`
	Ready        *bool           `json:"ready"`
	Name         *string         `json:"name"`
	Image        *string         `json:"image"`
	State        *ContainerState `json:"state"`
}

type ContextAttributes struct {
	Buckets       []*string              `json:"buckets,omitempty"`
	Domain        []*string              `json:"domain,omitempty"`
	Configuration map[string]interface{} `json:"configuration"`
	Protect       []*string              `json:"protect,omitempty"`
}

type CostAnalysis struct {
	Minutes       *float64 `json:"minutes"`
	CPUCost       *float64 `json:"cpuCost"`
	CPUEfficiency *float64 `json:"cpuEfficiency"`
	Efficiency    *float64 `json:"efficiency"`
	GpuCost       *float64 `json:"gpuCost"`
	NetworkCost   *float64 `json:"networkCost"`
	PvCost        *float64 `json:"pvCost"`
	RAMCost       *float64 `json:"ramCost"`
	RAMEfficiency *float64 `json:"ramEfficiency"`
	TotalCost     *float64 `json:"totalCost"`
	SharedCost    *float64 `json:"sharedCost"`
}

type CronJob struct {
	Metadata Metadata   `json:"metadata"`
	Status   CronStatus `json:"status"`
	Spec     CronSpec   `json:"spec"`
	Raw      string     `json:"raw"`
	Events   []*Event   `json:"events"`
	Jobs     []*Job     `json:"jobs"`
}

type CronSpec struct {
	Schedule          string  `json:"schedule"`
	Suspend           *bool   `json:"suspend"`
	ConcurrencyPolicy *string `json:"concurrencyPolicy"`
}

type CronStatus struct {
	Active           []*JobReference `json:"active"`
	LastScheduleTime *string         `json:"lastScheduleTime"`
}

type CrossVersionResourceTarget struct {
	APIVersion *string `json:"apiVersion"`
	Kind       *string `json:"kind"`
	Name       *string `json:"name"`
}

type Dashboard struct {
	ID   string        `json:"id"`
	Spec DashboardSpec `json:"spec"`
}

type DashboardGraph struct {
	Name    string             `json:"name"`
	Queries []*DashboardMetric `json:"queries"`
	Format  *string            `json:"format"`
}

type DashboardLabel struct {
	Name   string    `json:"name"`
	Values []*string `json:"values"`
}

type DashboardMetric struct {
	Legend  *string         `json:"legend"`
	Query   *string         `json:"query"`
	Results []*MetricResult `json:"results"`
}

type DashboardSpec struct {
	Name        *string           `json:"name"`
	Description *string           `json:"description"`
	Timeslices  []*string         `json:"timeslices"`
	Labels      []*DashboardLabel `json:"labels"`
	Graphs      []*DashboardGraph `json:"graphs"`
}

type DatabaseVolume struct {
	Size *string `json:"size"`
}

type Deployment struct {
	Metadata Metadata         `json:"metadata"`
	Status   DeploymentStatus `json:"status"`
	Spec     DeploymentSpec   `json:"spec"`
	Pods     []*Pod           `json:"pods"`
	Raw      string           `json:"raw"`
	Events   []*Event         `json:"events"`
}

func (Deployment) IsKubernetesData() {}

// global settings for CD, these specify global read/write policies and also allow for customization of the repos for CAPI resources and the deploy operator
type DeploymentSettings struct {
	ID string `json:"id"`
	// whether you've yet to enable CD for this instance
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
	// whether the byok cluster has been brought under self-management
	SelfManaged *bool `json:"selfManaged"`
	// the repo to fetch CAPI manifests from, for both providers and clusters
	ArtifactRepository *GitRepository `json:"artifactRepository"`
	// the repo to fetch the deploy operators manifests from
	DeployerRepository *GitRepository `json:"deployerRepository"`
	// read policy across all clusters
	ReadBindings []*PolicyBinding `json:"readBindings"`
	// write policy across all clusters
	WriteBindings []*PolicyBinding `json:"writeBindings"`
	// policy for managing git repos
	GitBindings []*PolicyBinding `json:"gitBindings"`
	// policy for creation of new clusters
	CreateBindings []*PolicyBinding `json:"createBindings"`
	InsertedAt     *string          `json:"insertedAt"`
	UpdatedAt      *string          `json:"updatedAt"`
}

type DeploymentSettingsAttributes struct {
	ArtifactRepositoryID *string                    `json:"artifactRepositoryId,omitempty"`
	DeployerRepositoryID *string                    `json:"deployerRepositoryId,omitempty"`
	ReadBindings         []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings        []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	GitBindings          []*PolicyBindingAttributes `json:"gitBindings,omitempty"`
	CreateBindings       []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type DeploymentSpec struct {
	Replicas *int64              `json:"replicas"`
	Strategy *DeploymentStrategy `json:"strategy"`
}

type DeploymentStatus struct {
	AvailableReplicas   *int64 `json:"availableReplicas"`
	Replicas            *int64 `json:"replicas"`
	ReadyReplicas       *int64 `json:"readyReplicas"`
	UnavailableReplicas *int64 `json:"unavailableReplicas"`
}

type DeploymentStrategy struct {
	Type          *string        `json:"type"`
	RollingUpdate *RollingUpdate `json:"rollingUpdate"`
}

type DiffNormalizerAttributes struct {
	Group       string   `json:"group"`
	Kind        string   `json:"kind"`
	Name        string   `json:"name"`
	Namespace   string   `json:"namespace"`
	JSONPatches []string `json:"jsonPatches,omitempty"`
}

type EnvAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type EnvFromAttributes struct {
	Secret    string `json:"secret"`
	ConfigMap string `json:"configMap"`
}

type Event struct {
	Action        *string `json:"action"`
	Count         *int64  `json:"count"`
	EventTime     *string `json:"eventTime"`
	LastTimestamp *string `json:"lastTimestamp"`
	Message       *string `json:"message"`
	Reason        *string `json:"reason"`
	Type          *string `json:"type"`
}

type FileContent struct {
	Path    *string `json:"path"`
	Content *string `json:"content"`
}

// spec for a job gate
type GateJobAttributes struct {
	Namespace string `json:"namespace"`
	// if you'd rather define the job spec via straight k8s yaml
	Raw            *string                `json:"raw,omitempty"`
	Containers     []*ContainerAttributes `json:"containers,omitempty"`
	Labels         map[string]interface{} `json:"labels,omitempty"`
	Annotations    map[string]interface{} `json:"annotations,omitempty"`
	ServiceAccount *string                `json:"serviceAccount,omitempty"`
}

// detailed gate specifications
type GateSpec struct {
	Job *JobGateSpec `json:"job"`
}

// a more refined spec for parameters needed for complex gates
type GateSpecAttributes struct {
	Job *GateJobAttributes `json:"job,omitempty"`
}

type GateStatusAttributes struct {
	JobRef *NamespacedName `json:"jobRef,omitempty"`
}

// the allowed inputs for a deployment agent gate update
type GateUpdateAttributes struct {
	State  *GateState            `json:"state,omitempty"`
	Status *GateStatusAttributes `json:"status,omitempty"`
}

type GcpCloudAttributes struct {
	Project *string `json:"project,omitempty"`
	Network *string `json:"network,omitempty"`
	Region  *string `json:"region,omitempty"`
}

type GcpSettingsAttributes struct {
	ApplicationCredentials string `json:"applicationCredentials"`
}

type GitAttributes struct {
	// the url of this repository
	URL string `json:"url"`
	// an ssh private key to use with this repo if an ssh url was given
	PrivateKey *string `json:"privateKey,omitempty"`
	// a passphrase to decrypt the given private key
	Passphrase *string `json:"passphrase,omitempty"`
	// the http username for authenticated http repos, defaults to apiKey for github
	Username *string `json:"username,omitempty"`
	// the http password for http authenticated repos
	Password *string `json:"password,omitempty"`
	// a manually supplied https path for non standard git setups.  This is auto-inferred in many cases
	HTTPSPath *string `json:"httpsPath,omitempty"`
	// similar to https_path, a manually supplied url format for custom git.  Should be something like {url}/tree/{ref}/{folder}
	URLFormat *string `json:"urlFormat,omitempty"`
}

// a file fetched from a git repository, eg a docs .md file
type GitFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

// a representation of where to pull manifests from git
type GitRef struct {
	// a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`
	Ref string `json:"ref"`
	// the folder manifests live under
	Folder string `json:"folder"`
}

type GitRefAttributes struct {
	Ref    string `json:"ref"`
	Folder string `json:"folder"`
}

// a git repository available for deployments
type GitRepository struct {
	// internal id of this repository
	ID string `json:"id"`
	// the git url of the repository, either https or ssh supported
	URL string `json:"url"`
	// whether its a http or ssh url
	AuthMethod *AuthMethod `json:"authMethod"`
	// whether we can currently pull this repo with the provided credentials
	Health *GitHealth `json:"health"`
	// the last successsful git pull timestamp
	PulledAt *string `json:"pulledAt"`
	// the error message if there were any pull errors
	Error *string `json:"error"`
	// the https url for this git repo
	HTTPSPath *string `json:"httpsPath"`
	// a format string to get the http url for a subfolder in a git repo
	URLFormat *string `json:"urlFormat"`
	// whether the current user can edit this repo
	Editable   *bool   `json:"editable"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type GitRepositoryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*GitRepositoryEdge `json:"edges"`
}

type GitRepositoryEdge struct {
	Node   *GitRepository `json:"node"`
	Cursor *string        `json:"cursor"`
}

type GitStatus struct {
	Cloned *bool   `json:"cloned"`
	Output *string `json:"output"`
}

// a rules based mechanism to redeploy a service across a fleet of clusters
type GlobalService struct {
	// internal id of this global service
	ID string `json:"id"`
	// a human readable name for this global service
	Name string `json:"name"`
	// a set of tags to select clusters for this global service
	Tags []*Tag `json:"tags"`
	// the service to replicate across clusters
	Service *ServiceDeployment `json:"service"`
	// whether to only apply to clusters with this provider
	Provider   *ClusterProvider `json:"provider"`
	InsertedAt *string          `json:"insertedAt"`
	UpdatedAt  *string          `json:"updatedAt"`
}

type GlobalServiceAttributes struct {
	Name       string           `json:"name"`
	Tags       []*TagAttributes `json:"tags,omitempty"`
	ProviderID *string          `json:"providerId,omitempty"`
}

type Group struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	InsertedAt  *string `json:"insertedAt"`
	UpdatedAt   *string `json:"updatedAt"`
}

type GroupAttributes struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
}

type GroupConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*GroupEdge `json:"edges"`
}

type GroupEdge struct {
	Node   *Group  `json:"node"`
	Cursor *string `json:"cursor"`
}

type GroupMember struct {
	ID         string  `json:"id"`
	User       *User   `json:"user"`
	Group      *Group  `json:"group"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type GroupMemberConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*GroupMemberEdge `json:"edges"`
}

type GroupMemberEdge struct {
	Node   *GroupMember `json:"node"`
	Cursor *string      `json:"cursor"`
}

// a chart manifest entry, including all versions
type HelmChartEntry struct {
	// the name of the chart
	Name *string `json:"name"`
	// all found versions of the chart
	Versions []*HelmChartVersion `json:"versions"`
}

// a chart version contained within a helm repository manifest
type HelmChartVersion struct {
	// the version of the app contained w/in this chart
	AppVersion *string `json:"appVersion"`
	// the version of the chart itself
	Version *string `json:"version"`
	// the name of the chart
	Name *string `json:"name"`
	Type *string `json:"type"`
	// sha digest of this chart's contents
	Digest *string `json:"digest"`
}

type HelmConfigAttributes struct {
	Values      *string         `json:"values,omitempty"`
	ValuesFiles []*string       `json:"valuesFiles,omitempty"`
	Chart       *string         `json:"chart,omitempty"`
	Version     *string         `json:"version,omitempty"`
	Repository  *NamespacedName `json:"repository,omitempty"`
}

// a crd representation of a helm repository
type HelmRepository struct {
	Metadata Metadata           `json:"metadata"`
	Spec     HelmRepositorySpec `json:"spec"`
	// the charts found in this repository (heavy operation, don't do in list endpoints)
	Charts []*HelmChartEntry `json:"charts"`
	// can fetch the status of a given helm repository
	Status *HelmRepositoryStatus `json:"status"`
}

// a specification of how a helm repository is fetched
type HelmRepositorySpec struct {
	Provider *string `json:"provider"`
	URL      string  `json:"url"`
	Type     *string `json:"type"`
}

// the state of this helm repository
type HelmRepositoryStatus struct {
	Ready   *bool   `json:"ready"`
	Message *string `json:"message"`
}

type HelmSpec struct {
	// the name of the chart this service is using
	Chart *string `json:"chart"`
	// a helm values file to use with this service, requires auth and so is heavy to query
	Values *string `json:"values"`
	// pointer to the flux helm repository resource used for this chart
	Repository *ObjectReference `json:"repository"`
	// the chart version in use currently
	Version *string `json:"version"`
	// a list of relative paths to values files to use for helm applies
	ValuesFiles []*string `json:"valuesFiles"`
}

type HTTPIngressRule struct {
	Paths []*IngressPath `json:"paths"`
}

type Ingress struct {
	Metadata     Metadata       `json:"metadata"`
	Status       ServiceStatus  `json:"status"`
	Spec         IngressSpec    `json:"spec"`
	Certificates []*Certificate `json:"certificates"`
	Raw          string         `json:"raw"`
	Events       []*Event       `json:"events"`
}

type IngressBackend struct {
	ServiceName *string `json:"serviceName"`
	ServicePort *string `json:"servicePort"`
}

type IngressPath struct {
	Backend *IngressBackend `json:"backend"`
	Path    *string         `json:"path"`
}

type IngressRule struct {
	Host *string          `json:"host"`
	HTTP *HTTPIngressRule `json:"http"`
}

type IngressSpec struct {
	Rules []*IngressRule `json:"rules"`
	TLS   []*IngressTLS  `json:"tls"`
}

type IngressTLS struct {
	Hosts []*string `json:"hosts"`
}

type Installation struct {
	ID         string      `json:"id"`
	Repository *Repository `json:"repository"`
}

type InstallationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*InstallationEdge `json:"edges"`
}

type InstallationEdge struct {
	Node   *Installation `json:"node"`
	Cursor *string       `json:"cursor"`
}

type Invite struct {
	SecureID string  `json:"secureId"`
	Email    *string `json:"email"`
}

type InviteAttributes struct {
	Email *string `json:"email,omitempty"`
}

type IssuerRef struct {
	Group *string `json:"group"`
	Kind  *string `json:"kind"`
	Name  *string `json:"name"`
}

type Job struct {
	Metadata Metadata  `json:"metadata"`
	Status   JobStatus `json:"status"`
	Spec     JobSpec   `json:"spec"`
	Raw      string    `json:"raw"`
	Events   []*Event  `json:"events"`
	Pods     []*Pod    `json:"pods"`
}

// the full specification of a job gate
type JobGateSpec struct {
	// the namespace the job will run in
	Namespace string `json:"namespace"`
	// a raw kubernetes job resource, overrides any other configuration
	Raw *string `json:"raw"`
	// list of containers to run in this job
	Containers []*ContainerSpec `json:"containers"`
	// any pod labels to apply
	Labels map[string]interface{} `json:"labels"`
	// any pod annotations to apply
	Annotations map[string]interface{} `json:"annotations"`
	// the service account the pod will use
	ServiceAccount *string `json:"serviceAccount"`
}

type JobReference struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

type JobSpec struct {
	BackoffLimit          *int64 `json:"backoffLimit"`
	Parallelism           *int64 `json:"parallelism"`
	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds"`
}

type JobStatus struct {
	Active         *int64  `json:"active"`
	CompletionTime *string `json:"completionTime"`
	StartTime      *string `json:"startTime"`
	Succeeded      *int64  `json:"succeeded"`
	Failed         *int64  `json:"failed"`
}

type KubeconfigAttributes struct {
	Raw *string `json:"raw,omitempty"`
}

type KubernetesDatasource struct {
	Resource string `json:"resource"`
	Name     string `json:"name"`
}

type KubernetesUnstructured struct {
	Raw      map[string]interface{} `json:"raw"`
	Metadata Metadata               `json:"metadata"`
	Events   []*Event               `json:"events"`
}

// metadata needed for configuring kustomize
type Kustomize struct {
	Path string `json:"path"`
}

type KustomizeAttributes struct {
	// the path to the kustomization file to use
	Path string `json:"path"`
}

type LabelInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type LabelPair struct {
	Name  *string `json:"name"`
	Value *string `json:"value"`
}

type License struct {
	Metadata Metadata       `json:"metadata"`
	Spec     LicenseSpec    `json:"spec"`
	Status   *LicenseStatus `json:"status"`
}

type LicenseFeature struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
}

type LicenseSpec struct {
	SecretRef SecretKeySelector `json:"secretRef"`
}

type LicenseStatus struct {
	Plan     *string                `json:"plan"`
	Free     *bool                  `json:"free"`
	Features []*LicenseFeature      `json:"features"`
	Limits   map[string]interface{} `json:"limits"`
	Secrets  map[string]interface{} `json:"secrets"`
}

type LoadBalancerIngressStatus struct {
	Hostname *string `json:"hostname"`
	IP       *string `json:"ip"`
}

type LoadBalancerStatus struct {
	Ingress []*LoadBalancerIngressStatus `json:"ingress"`
}

type LogFilter struct {
	Metadata Metadata      `json:"metadata"`
	Spec     LogFilterSpec `json:"spec"`
}

type LogFilterSpec struct {
	Name        *string     `json:"name"`
	Description *string     `json:"description"`
	Query       *string     `json:"query"`
	Labels      []*LogLabel `json:"labels"`
}

type LogLabel struct {
	Name  *string `json:"name"`
	Value *string `json:"value"`
}

type LogStream struct {
	Stream map[string]interface{} `json:"stream"`
	Values []*MetricResult        `json:"values"`
}

type LoginInfo struct {
	OidcURI *string `json:"oidcUri"`
}

type ManifestNetwork struct {
	PluralDNS *bool   `json:"pluralDns"`
	Subdomain *string `json:"subdomain"`
}

type Metadata struct {
	Labels            []*LabelPair `json:"labels"`
	Annotations       []*LabelPair `json:"annotations"`
	Name              string       `json:"name"`
	Namespace         *string      `json:"namespace"`
	CreationTimestamp *string      `json:"creationTimestamp"`
}

type MetadataAttributes struct {
	Labels      map[string]interface{} `json:"labels,omitempty"`
	Annotations map[string]interface{} `json:"annotations,omitempty"`
}

type MetricResponse struct {
	Metric map[string]interface{} `json:"metric"`
	Values []*MetricResult        `json:"values"`
}

type MetricResult struct {
	Timestamp *string `json:"timestamp"`
	Value     *string `json:"value"`
}

type Namespace struct {
	Status   NamespaceStatus `json:"status"`
	Spec     NamespaceSpec   `json:"spec"`
	Metadata Metadata        `json:"metadata"`
	Raw      string          `json:"raw"`
	Events   []*Event        `json:"events"`
}

// metadata fields for created namespaces
type NamespaceMetadata struct {
	Labels      map[string]interface{} `json:"labels"`
	Annotations map[string]interface{} `json:"annotations"`
}

type NamespaceSpec struct {
	Finalizers []*string `json:"finalizers"`
}

type NamespaceStatus struct {
	Phase *string `json:"phase"`
}

type NamespacedName struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

type Node struct {
	Status   NodeStatus `json:"status"`
	Spec     NodeSpec   `json:"spec"`
	Metadata Metadata   `json:"metadata"`
	Raw      string     `json:"raw"`
	Pods     []*Pod     `json:"pods"`
	Events   []*Event   `json:"events"`
}

type NodeCondition struct {
	Message *string `json:"message"`
	Reason  *string `json:"reason"`
	Status  *string `json:"status"`
	Type    *string `json:"type"`
}

type NodeMetric struct {
	Metadata  Metadata   `json:"metadata"`
	Timestamp *string    `json:"timestamp"`
	Window    *string    `json:"window"`
	Usage     *NodeUsage `json:"usage"`
}

// a specification for a node pool to be created in this cluster
type NodePool struct {
	// internal id for this node pool
	ID string `json:"id"`
	// name of this node pool (must be unique)
	Name string `json:"name"`
	// minimum number of instances in this node pool
	MinSize int64 `json:"minSize"`
	// maximum number of instances in this node pool
	MaxSize int64 `json:"maxSize"`
	// the type of node to use (usually cloud-specific)
	InstanceType string `json:"instanceType"`
	// whether this is a spot pool or not
	Spot *bool `json:"spot"`
	// kubernetes labels to apply to the nodes in this pool, useful for node selectors
	Labels map[string]interface{} `json:"labels"`
	// any taints you'd want to apply to a node, for eg preventing scheduling on spot instances
	Taints []*Taint `json:"taints"`
	// cloud specific settings for the node groups
	CloudSettings *CloudSettings `json:"cloudSettings"`
	InsertedAt    *string        `json:"insertedAt"`
	UpdatedAt     *string        `json:"updatedAt"`
}

type NodePoolAttributes struct {
	Name          string                   `json:"name"`
	MinSize       int64                    `json:"minSize"`
	MaxSize       int64                    `json:"maxSize"`
	InstanceType  string                   `json:"instanceType"`
	Labels        map[string]interface{}   `json:"labels,omitempty"`
	Taints        []*TaintAttributes       `json:"taints,omitempty"`
	CloudSettings *CloudSettingsAttributes `json:"cloudSettings,omitempty"`
}

type NodeSpec struct {
	PodCidr       *string `json:"podCidr"`
	ProviderID    *string `json:"providerId"`
	Unschedulable *bool   `json:"unschedulable"`
}

type NodeStatus struct {
	Allocatable map[string]interface{} `json:"allocatable"`
	Capacity    map[string]interface{} `json:"capacity"`
	Phase       *string                `json:"phase"`
	Conditions  []*NodeCondition       `json:"conditions"`
}

type NodeUsage struct {
	CPU    *string `json:"cpu"`
	Memory *string `json:"memory"`
}

type Notification struct {
	ID          string                 `json:"id"`
	Title       string                 `json:"title"`
	Description *string                `json:"description"`
	Fingerprint string                 `json:"fingerprint"`
	Status      *NotificationStatus    `json:"status"`
	Labels      map[string]interface{} `json:"labels"`
	Annotations map[string]interface{} `json:"annotations"`
	Repository  string                 `json:"repository"`
	SeenAt      *string                `json:"seenAt"`
	Severity    *Severity              `json:"severity"`
	InsertedAt  *string                `json:"insertedAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type NotificationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*NotificationEdge `json:"edges"`
}

type NotificationDelta struct {
	Delta   *Delta        `json:"delta"`
	Payload *Notification `json:"payload"`
}

type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor *string       `json:"cursor"`
}

type ObjectReference struct {
	Name      *string `json:"name"`
	Namespace *string `json:"namespace"`
}

type OverlayUpdate struct {
	Path []*string `json:"path"`
}

type PageInfo struct {
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor"`
}

type PathUpdate struct {
	Path      []*string `json:"path"`
	ValueFrom string    `json:"valueFrom"`
}

// a release pipeline, composed of multiple stages each with potentially multiple services
type Pipeline struct {
	ID string `json:"id"`
	// the name of the pipeline
	Name string `json:"name"`
	// the stages of this pipeline
	Stages []*PipelineStage `json:"stages"`
	// edges linking two stages w/in the pipeline in a full DAG
	Edges      []*PipelineStageEdge `json:"edges"`
	InsertedAt *string              `json:"insertedAt"`
	UpdatedAt  *string              `json:"updatedAt"`
}

// the top level input object for creating/deleting pipelines
type PipelineAttributes struct {
	Stages []*PipelineStageAttributes `json:"stages,omitempty"`
	Edges  []*PipelineEdgeAttributes  `json:"edges,omitempty"`
}

type PipelineConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*PipelineEdge `json:"edges"`
}

type PipelineEdge struct {
	Node   *Pipeline `json:"node"`
	Cursor *string   `json:"cursor"`
}

// specification of an edge between two pipeline stages
type PipelineEdgeAttributes struct {
	// stage id the edge is from, can also be specified by name
	FromID *string `json:"fromId,omitempty"`
	// stage id the edge is to, can also be specified by name
	ToID *string `json:"toId,omitempty"`
	// the name of the pipeline stage this edge emits from
	From *string `json:"from,omitempty"`
	// the name of the pipeline stage this edge points to
	To *string `json:"to,omitempty"`
	// any optional promotion gates you wish to configure
	Gates []*PipelineGateAttributes `json:"gates,omitempty"`
}

// A gate blocking promotion along a release pipeline
type PipelineGate struct {
	ID string `json:"id"`
	// the name of this gate as seen in the UI
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the current state of this gate
	State GateState `json:"state"`
	// more detailed specification for complex gates
	Spec *GateSpec `json:"spec"`
	// the last user to approve this gate
	Approver   *User   `json:"approver"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

// will configure a promotion gate for a pipeline
type PipelineGateAttributes struct {
	// the name of this gate
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the handle of a cluster this gate will execute on
	Cluster *string `json:"cluster,omitempty"`
	// the id of the cluster this gate will execute on
	ClusterID *string `json:"clusterId,omitempty"`
	// a specification for more complex gate types
	Spec *GateSpecAttributes `json:"spec,omitempty"`
}

// a representation of an individual pipeline promotion, which is a list of services/revisions and timestamps to determine promotion status
type PipelinePromotion struct {
	ID string `json:"id"`
	// the last time this promotion was updated
	RevisedAt *string `json:"revisedAt"`
	// the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at
	PromotedAt *string `json:"promotedAt"`
	// the services included in this promotion
	Services   []*PromotionService `json:"services"`
	InsertedAt *string             `json:"insertedAt"`
	UpdatedAt  *string             `json:"updatedAt"`
}

// a pipeline stage, has a list of services and potentially a promotion which might be pending
type PipelineStage struct {
	ID string `json:"id"`
	// the name of this stage (eg dev, prod, staging)
	Name string `json:"name"`
	// the services within this stage
	Services []*StageService `json:"services"`
	// a promotion which might be outstanding for this stage
	Promotion  *PipelinePromotion `json:"promotion"`
	InsertedAt *string            `json:"insertedAt"`
	UpdatedAt  *string            `json:"updatedAt"`
}

// specification of a stage of a pipeline
type PipelineStageAttributes struct {
	Name     string                    `json:"name"`
	Services []*StageServiceAttributes `json:"services,omitempty"`
}

// an edge in the pipeline DAG
type PipelineStageEdge struct {
	ID string `json:"id"`
	// when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted
	PromotedAt *string         `json:"promotedAt"`
	From       PipelineStage   `json:"from"`
	To         PipelineStage   `json:"to"`
	Gates      []*PipelineGate `json:"gates"`
	InsertedAt *string         `json:"insertedAt"`
	UpdatedAt  *string         `json:"updatedAt"`
}

type Plan struct {
	ID     *string `json:"id"`
	Name   *string `json:"name"`
	Period *string `json:"period"`
}

type PluralContext struct {
	Buckets       []*string              `json:"buckets"`
	Domains       []*string              `json:"domains"`
	Configuration map[string]interface{} `json:"configuration"`
}

type PluralManifest struct {
	Network      *ManifestNetwork `json:"network"`
	BucketPrefix *string          `json:"bucketPrefix"`
	Cluster      *string          `json:"cluster"`
}

type PluralSubscription struct {
	ID   *string `json:"id"`
	Plan *Plan   `json:"plan"`
}

type Pod struct {
	Status   PodStatus `json:"status"`
	Spec     PodSpec   `json:"spec"`
	Metadata Metadata  `json:"metadata"`
	Raw      string    `json:"raw"`
	Logs     []*string `json:"logs"`
	Events   []*Event  `json:"events"`
}

type PodCondition struct {
	LastProbeTime      *string `json:"lastProbeTime"`
	LastTransitionTime *string `json:"lastTransitionTime"`
	Message            *string `json:"message"`
	Reason             *string `json:"reason"`
	Status             *string `json:"status"`
	Type               *string `json:"type"`
}

type PodConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []*PodEdge `json:"edges"`
}

type PodDelta struct {
	Delta   *Delta `json:"delta"`
	Payload *Pod   `json:"payload"`
}

type PodEdge struct {
	Node   *Pod    `json:"node"`
	Cursor *string `json:"cursor"`
}

type PodSpec struct {
	ServiceAccountName *string      `json:"serviceAccountName"`
	NodeName           *string      `json:"nodeName"`
	Containers         []*Container `json:"containers"`
	InitContainers     []*Container `json:"initContainers"`
}

type PodStatus struct {
	Message               *string            `json:"message"`
	Phase                 *string            `json:"phase"`
	HostIP                *string            `json:"hostIp"`
	PodIP                 *string            `json:"podIp"`
	Reason                *string            `json:"reason"`
	Conditions            []*PodCondition    `json:"conditions"`
	ContainerStatuses     []*ContainerStatus `json:"containerStatuses"`
	InitContainerStatuses []*ContainerStatus `json:"initContainerStatuses"`
}

type PolicyBinding struct {
	ID    *string `json:"id"`
	User  *User   `json:"user"`
	Group *Group  `json:"group"`
}

type PolicyBindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

type Port struct {
	HostPort      *int64  `json:"hostPort"`
	ContainerPort *int64  `json:"containerPort"`
	Protocol      *string `json:"protocol"`
}

type PostgresInstance struct {
	UID string `json:"uid"`
}

type PostgresSettings struct {
	Version *string `json:"version"`
}

type Postgresql struct {
	Metadata  Metadata            `json:"metadata"`
	Spec      PostgresqlSpec      `json:"spec"`
	Status    *PostgresqlStatus   `json:"status"`
	Instances []*PostgresInstance `json:"instances"`
}

type PostgresqlSpec struct {
	TeamID            *string                `json:"teamId"`
	Users             map[string]interface{} `json:"users"`
	Resources         *Resources             `json:"resources"`
	Postgresql        *PostgresSettings      `json:"postgresql"`
	NumberOfInstances *int64                 `json:"numberOfInstances"`
	Databases         map[string]interface{} `json:"databases"`
	Volume            *DatabaseVolume        `json:"volume"`
	Pods              []*Pod                 `json:"pods"`
}

type PostgresqlStatus struct {
	ClusterStatus *string `json:"clusterStatus"`
}

type PrometheusDatasource struct {
	Query  string  `json:"query"`
	Format *string `json:"format"`
	Legend *string `json:"legend"`
}

// how a promotion for a service will be performed
type PromotionCriteria struct {
	ID string `json:"id"`
	// the source service in a prior stage to promote settings from
	Source *ServiceDeployment `json:"source"`
	// whether you want to copy any configuration values from the source service
	Secrets    []*string `json:"secrets"`
	InsertedAt *string   `json:"insertedAt"`
	UpdatedAt  *string   `json:"updatedAt"`
}

// actions to perform if this stage service were promoted
type PromotionCriteriaAttributes struct {
	// the handle of the cluster for the source service
	Handle *string `json:"handle,omitempty"`
	// the name of the source service
	Name *string `json:"name,omitempty"`
	// the id of the service to promote from
	SourceID *string `json:"sourceId,omitempty"`
	// the secrets to copy over in a promotion
	Secrets []*string `json:"secrets,omitempty"`
}

// a service to be potentially promoted
type PromotionService struct {
	ID string `json:"id"`
	// a service to promote
	Service *ServiceDeployment `json:"service"`
	// the revision of the service to promote
	Revision   *Revision `json:"revision"`
	InsertedAt *string   `json:"insertedAt"`
	UpdatedAt  *string   `json:"updatedAt"`
}

// a cloud credential that can be used while creating new clusters
type ProviderCredential struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	Namespace  string  `json:"namespace"`
	Kind       string  `json:"kind"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type ProviderCredentialAttributes struct {
	Namespace *string `json:"namespace,omitempty"`
	Name      string  `json:"name"`
	Kind      *string `json:"kind,omitempty"`
}

type RbacAttributes struct {
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type Recipe struct {
	ID             string           `json:"id"`
	Name           string           `json:"name"`
	Description    *string          `json:"description"`
	Provider       *string          `json:"provider"`
	Restricted     *bool            `json:"restricted"`
	RecipeSections []*RecipeSection `json:"recipeSections"`
	OidcEnabled    *bool            `json:"oidcEnabled"`
}

type RecipeConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []*RecipeEdge `json:"edges"`
}

type RecipeEdge struct {
	Node   *Recipe `json:"node"`
	Cursor *string `json:"cursor"`
}

type RecipeItem struct {
	ID            string               `json:"id"`
	Configuration []*ConfigurationItem `json:"configuration"`
}

type RecipeSection struct {
	ID            string               `json:"id"`
	Repository    *Repository          `json:"repository"`
	RecipeItems   []*RecipeItem        `json:"recipeItems"`
	Configuration []*ConfigurationItem `json:"configuration"`
}

type Recommendation struct {
	ContainerRecommendations []*ContainerRecommendation `json:"containerRecommendations"`
}

type Repository struct {
	ID            string         `json:"id"`
	Name          string         `json:"name"`
	Description   *string        `json:"description"`
	Icon          *string        `json:"icon"`
	Docs          []*FileContent `json:"docs"`
	Configuration *Configuration `json:"configuration"`
	GrafanaDNS    *string        `json:"grafanaDns"`
}

type RepositoryConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*RepositoryEdge `json:"edges"`
}

type RepositoryContext struct {
	Repository string                 `json:"repository"`
	Context    map[string]interface{} `json:"context"`
}

type RepositoryEdge struct {
	Node   *Repository `json:"node"`
	Cursor *string     `json:"cursor"`
}

type ResourceSpec struct {
	CPU    *string `json:"cpu"`
	Memory *string `json:"memory"`
}

type Resources struct {
	Limits   *ResourceSpec `json:"limits"`
	Requests *ResourceSpec `json:"requests"`
}

// a representation of a past revision of a service
type Revision struct {
	// id of this revision
	ID string `json:"id"`
	// the service's semver
	Version string `json:"version"`
	// git spec of the prior revision
	Git *GitRef `json:"git"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm"`
	// the sha this service was pulled from
	Sha *string `json:"sha"`
	// the commit message for this revision
	Message    *string `json:"message"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type RevisionConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*RevisionEdge `json:"edges"`
}

type RevisionEdge struct {
	Node   *Revision `json:"node"`
	Cursor *string   `json:"cursor"`
}

type Role struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Description  *string        `json:"description"`
	Repositories []*string      `json:"repositories"`
	Permissions  []*Permission  `json:"permissions"`
	RoleBindings []*RoleBinding `json:"roleBindings"`
	InsertedAt   *string        `json:"insertedAt"`
	UpdatedAt    *string        `json:"updatedAt"`
}

type RoleAttributes struct {
	Name         *string              `json:"name,omitempty"`
	Description  *string              `json:"description,omitempty"`
	Repositories []*string            `json:"repositories,omitempty"`
	RoleBindings []*BindingAttributes `json:"roleBindings,omitempty"`
	Permissions  []*Permission        `json:"permissions,omitempty"`
}

type RoleBinding struct {
	ID         string  `json:"id"`
	User       *User   `json:"user"`
	Group      *Group  `json:"group"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type RoleConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*RoleEdge `json:"edges"`
}

type RoleEdge struct {
	Node   *Role   `json:"node"`
	Cursor *string `json:"cursor"`
}

type RollingUpdate struct {
	MaxSurge       *int64 `json:"maxSurge"`
	MaxUnavailable *int64 `json:"maxUnavailable"`
}

type Runbook struct {
	Name       string                      `json:"name"`
	Spec       RunbookSpec                 `json:"spec"`
	Status     *RunbookStatus              `json:"status"`
	Data       []*RunbookData              `json:"data"`
	Executions *RunbookExecutionConnection `json:"executions"`
}

type RunbookAction struct {
	Name          string               `json:"name"`
	Type          string               `json:"type"`
	Configuration *ConfigurationAction `json:"configuration"`
}

type RunbookActionInput struct {
	Action  string                 `json:"action"`
	Context map[string]interface{} `json:"context"`
}

type RunbookActionResponse struct {
	RedirectTo *string `json:"redirectTo"`
}

type RunbookAlertStatus struct {
	Name        string                 `json:"name"`
	StartsAt    *string                `json:"startsAt"`
	Fingerprint *string                `json:"fingerprint"`
	Annotations map[string]interface{} `json:"annotations"`
	Labels      map[string]interface{} `json:"labels"`
}

type RunbookContext struct {
	TimeseriesStart *int64  `json:"timeseriesStart,omitempty"`
	TimeseriesStep  *string `json:"timeseriesStep,omitempty"`
}

type RunbookData struct {
	Name       string             `json:"name"`
	Source     *RunbookDatasource `json:"source"`
	Kubernetes KubernetesData     `json:"kubernetes"`
	Prometheus []*MetricResponse  `json:"prometheus"`
	Nodes      []*Node            `json:"nodes"`
}

type RunbookDatasource struct {
	Name       string                `json:"name"`
	Type       string                `json:"type"`
	Prometheus *PrometheusDatasource `json:"prometheus"`
	Kubernetes *KubernetesDatasource `json:"kubernetes"`
}

type RunbookExecution struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Namespace  string                 `json:"namespace"`
	Context    map[string]interface{} `json:"context"`
	User       *User                  `json:"user"`
	InsertedAt *string                `json:"insertedAt"`
	UpdatedAt  *string                `json:"updatedAt"`
}

type RunbookExecutionConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*RunbookExecutionEdge `json:"edges"`
}

type RunbookExecutionEdge struct {
	Node   *RunbookExecution `json:"node"`
	Cursor *string           `json:"cursor"`
}

type RunbookSpec struct {
	Name        string                 `json:"name"`
	Description *string                `json:"description"`
	Display     map[string]interface{} `json:"display"`
	Datasources []*RunbookDatasource   `json:"datasources"`
	Actions     []*RunbookAction       `json:"actions"`
}

type RunbookStatus struct {
	Alerts []*RunbookAlertStatus `json:"alerts"`
}

type RunningState struct {
	StartedAt *string `json:"startedAt"`
}

// a full specification of a kubernetes runtime component's requirements
type RuntimeAddon struct {
	// an icon to identify this runtime add-on
	Icon     *string         `json:"icon"`
	Versions []*AddonVersion `json:"versions"`
}

// a service encapsulating a controller like istio/ingress-nginx/etc that is meant to extend the kubernetes api
type RuntimeService struct {
	ID string `json:"id"`
	// add-on name
	Name string `json:"name"`
	// add-on version, should be semver formatted
	Version string `json:"version"`
	// the full specification of this kubernetes add-on
	Addon *RuntimeAddon `json:"addon"`
	// the version of the add-on you've currently deployed
	AddonVersion *AddonVersion `json:"addonVersion"`
	// the plural service it came from
	Service    *ServiceDeployment `json:"service"`
	InsertedAt *string            `json:"insertedAt"`
	UpdatedAt  *string            `json:"updatedAt"`
}

type RuntimeServiceAttributes struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type Secret struct {
	Metadata Metadata               `json:"metadata"`
	Type     *string                `json:"type"`
	Data     map[string]interface{} `json:"data"`
}

type SecretKeySelector struct {
	Name string  `json:"name"`
	Key  *string `json:"key"`
}

type Service struct {
	Metadata Metadata      `json:"metadata"`
	Status   ServiceStatus `json:"status"`
	Spec     ServiceSpec   `json:"spec"`
	Pods     []*Pod        `json:"pods"`
	Raw      string        `json:"raw"`
	Events   []*Event      `json:"events"`
}

type ServiceCloneAttributes struct {
	Name          string              `json:"name"`
	Namespace     *string             `json:"namespace,omitempty"`
	Configuration []*ConfigAttributes `json:"configuration,omitempty"`
}

// representation of a kubernetes component deployed by a service
type ServiceComponent struct {
	// internal id
	ID string `json:"id"`
	// kubernetes component health enum
	State *ComponentState `json:"state"`
	// whether this component has been applied to the k8s api
	Synced bool `json:"synced"`
	// api group of this resource
	Group *string `json:"group"`
	// api version of this resource
	Version *string `json:"version"`
	// api kind of this resource
	Kind string `json:"kind"`
	// kubernetes namespace of this resource
	Namespace *string `json:"namespace"`
	// kubernetes name of this resource
	Name string `json:"name"`
	// the service this component belongs to
	Service *ServiceDeployment `json:"service"`
	// any api deprecations discovered from this component
	APIDeprecations []*APIDeprecation `json:"apiDeprecations"`
}

// a configuration item k/v pair
type ServiceConfiguration struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// a reference to a service deployed from a git repo into a cluster
type ServiceDeployment struct {
	// internal id of this service
	ID string `json:"id"`
	// human readable name of this service, must be unique per cluster
	Name string `json:"name"`
	// kubernetes namespace this service will be deployed to
	Namespace string `json:"namespace"`
	// A summary status enum for the health of this service
	Status ServiceDeploymentStatus `json:"status"`
	// semver of this service
	Version string `json:"version"`
	// description on where in git the service's manifests should be fetched
	Git *GitRef `json:"git"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm"`
	// if true, deletion of this service is not allowed
	Protect *bool `json:"protect"`
	// latest git sha we pulled from
	Sha *string `json:"sha"`
	// https url to fetch the latest tarball of kubernetes manifests
	Tarball *string `json:"tarball"`
	// a n / m representation of the number of healthy components of this service
	ComponentStatus *string `json:"componentStatus"`
	// settings for advanced tuning of the sync process
	SyncConfig *SyncConfig `json:"syncConfig"`
	// kustomize related service metadata
	Kustomize *Kustomize `json:"kustomize"`
	// the commit message currently in use
	Message *string `json:"message"`
	// the time this service was scheduled for deletion
	DeletedAt *string `json:"deletedAt"`
	// fetches the /docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries
	Docs []*GitFile `json:"docs"`
	// the git repo of this service
	Repository     *GitRepository  `json:"repository"`
	HelmRepository *HelmRepository `json:"helmRepository"`
	// read policy for this service
	ReadBindings []*PolicyBinding `json:"readBindings"`
	// write policy of this service
	WriteBindings []*PolicyBinding `json:"writeBindings"`
	// a list of errors generated by the deployment operator
	Errors []*ServiceError `json:"errors"`
	// the cluster this service is deployed into
	Cluster *Cluster `json:"cluster"`
	// the current revision of this service
	Revision *Revision `json:"revision"`
	// possibly secret configuration used to template the manifests of this service
	Configuration []*ServiceConfiguration `json:"configuration"`
	// the kubernetes component of a service
	Components []*ServiceComponent `json:"components"`
	// the global service this service is the source for
	GlobalService *GlobalService `json:"globalService"`
	// whether this service is controlled by a global service
	Owner *GlobalService `json:"owner"`
	// a relay connection of all revisions of this service, these are periodically pruned up to a history limit
	Revisions *RevisionConnection `json:"revisions"`
	// whether this service is editable
	Editable   *bool   `json:"editable"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
}

type ServiceDeploymentAttributes struct {
	Name          string                     `json:"name"`
	Namespace     string                     `json:"namespace"`
	Version       *string                    `json:"version,omitempty"`
	DocsPath      *string                    `json:"docsPath,omitempty"`
	SyncConfig    *SyncConfigAttributes      `json:"syncConfig,omitempty"`
	Protect       *bool                      `json:"protect,omitempty"`
	RepositoryID  string                     `json:"repositoryId"`
	Git           *GitRefAttributes          `json:"git,omitempty"`
	Helm          *HelmConfigAttributes      `json:"helm,omitempty"`
	Kustomize     *KustomizeAttributes       `json:"kustomize,omitempty"`
	Configuration []*ConfigAttributes        `json:"configuration,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type ServiceDeploymentConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []*ServiceDeploymentEdge `json:"edges"`
}

type ServiceDeploymentEdge struct {
	Node   *ServiceDeployment `json:"node"`
	Cursor *string            `json:"cursor"`
}

// an error sent from the deploy operator about sync progress
type ServiceError struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

type ServiceErrorAttributes struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

type ServicePort struct {
	Name       *string `json:"name"`
	Protocol   *string `json:"protocol"`
	Port       *int64  `json:"port"`
	TargetPort *string `json:"targetPort"`
}

type ServiceSpec struct {
	Type      *string                `json:"type"`
	ClusterIP *string                `json:"clusterIp"`
	Selector  map[string]interface{} `json:"selector"`
	Ports     []*ServicePort         `json:"ports"`
}

type ServiceStatus struct {
	LoadBalancer *LoadBalancerStatus `json:"loadBalancer"`
}

// a rollup count of the statuses of services in a query
type ServiceStatusCount struct {
	Status ServiceDeploymentStatus `json:"status"`
	Count  int64                   `json:"count"`
}

type ServiceUpdateAttributes struct {
	Version       *string               `json:"version,omitempty"`
	Protect       *bool                 `json:"protect,omitempty"`
	Git           *GitRefAttributes     `json:"git,omitempty"`
	Helm          *HelmConfigAttributes `json:"helm,omitempty"`
	Configuration []*ConfigAttributes   `json:"configuration,omitempty"`
	Kustomize     *KustomizeAttributes  `json:"kustomize,omitempty"`
}

type SMTP struct {
	Server   *string `json:"server"`
	Port     *int64  `json:"port"`
	Password *string `json:"password"`
	Sender   *string `json:"sender"`
	User     *string `json:"user"`
}

type SMTPInput struct {
	Server   *string `json:"server,omitempty"`
	Port     *int64  `json:"port,omitempty"`
	Password *string `json:"password,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	User     *string `json:"user,omitempty"`
}

type Stack struct {
	ID         string           `json:"id"`
	Name       string           `json:"name"`
	Bundles    []*Recipe        `json:"bundles"`
	Sections   []*RecipeSection `json:"sections"`
	InsertedAt *string          `json:"insertedAt"`
	UpdatedAt  *string          `json:"updatedAt"`
}

// the configuration of a service within a pipeline stage, including optional promotion criteria
type StageService struct {
	ID string `json:"id"`
	// a pointer to a service
	Service *ServiceDeployment `json:"service"`
	// criteria for how a promotion of this service shall be performed
	Criteria   *PromotionCriteria `json:"criteria"`
	InsertedAt *string            `json:"insertedAt"`
	UpdatedAt  *string            `json:"updatedAt"`
}

// the attributes of a service w/in a specific stage
type StageServiceAttributes struct {
	// the cluster handle of this service
	Handle *string `json:"handle,omitempty"`
	// the name of this service
	Name *string `json:"name,omitempty"`
	// the name of this service
	ServiceID *string                      `json:"serviceId,omitempty"`
	Criteria  *PromotionCriteriaAttributes `json:"criteria,omitempty"`
}

type StatefulSet struct {
	Metadata Metadata          `json:"metadata"`
	Status   StatefulSetStatus `json:"status"`
	Spec     StatefulSetSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events"`
}

func (StatefulSet) IsKubernetesData() {}

type StatefulSetSpec struct {
	Replicas    *int64  `json:"replicas"`
	ServiceName *string `json:"serviceName"`
}

type StatefulSetStatus struct {
	CurrentReplicas *int64 `json:"currentReplicas"`
	Replicas        *int64 `json:"replicas"`
	ReadyReplicas   *int64 `json:"readyReplicas"`
	UpdatedReplicas *int64 `json:"updatedReplicas"`
}

type StatusComponent struct {
	Group  *string `json:"group"`
	Kind   string  `json:"kind"`
	Name   string  `json:"name"`
	Status string  `json:"status"`
}

type StatusCondition struct {
	Message string `json:"message"`
	Reason  string `json:"reason"`
	Status  string `json:"status"`
	Type    string `json:"type"`
}

// Advanced configuration of how to sync resources
type SyncConfig struct {
	NamespaceMetadata *NamespaceMetadata `json:"namespaceMetadata"`
}

type SyncConfigAttributes struct {
	NamespaceMetadata *MetadataAttributes       `json:"namespaceMetadata,omitempty"`
	DiffNormalizer    *DiffNormalizerAttributes `json:"diffNormalizer,omitempty"`
}

type Tag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// a kubernetes node taint
type Taint struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TaintAttributes struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TerminatedState struct {
	ExitCode   *int64  `json:"exitCode"`
	FinishedAt *string `json:"finishedAt"`
	StartedAt  *string `json:"startedAt"`
	Message    *string `json:"message"`
	Reason     *string `json:"reason"`
}

type UpgradePolicy struct {
	ID           string            `json:"id"`
	Name         string            `json:"name"`
	Description  *string           `json:"description"`
	Repositories []*string         `json:"repositories"`
	Type         UpgradePolicyType `json:"type"`
	Target       string            `json:"target"`
	Weight       *int64            `json:"weight"`
	InsertedAt   *string           `json:"insertedAt"`
	UpdatedAt    *string           `json:"updatedAt"`
}

type UpgradePolicyAttributes struct {
	Name         string            `json:"name"`
	Description  *string           `json:"description,omitempty"`
	Target       string            `json:"target"`
	Type         UpgradePolicyType `json:"type"`
	Repositories []*string         `json:"repositories,omitempty"`
	Weight       *int64            `json:"weight,omitempty"`
}

type User struct {
	ID                  string     `json:"id"`
	Name                string     `json:"name"`
	Email               string     `json:"email"`
	DeletedAt           *string    `json:"deletedAt"`
	Profile             *string    `json:"profile"`
	PluralID            *string    `json:"pluralId"`
	Roles               *UserRoles `json:"roles"`
	ReadTimestamp       *string    `json:"readTimestamp"`
	BuildTimestamp      *string    `json:"buildTimestamp"`
	Groups              []*Group   `json:"groups"`
	BoundRoles          []*Role    `json:"boundRoles"`
	Jwt                 *string    `json:"jwt"`
	UnreadNotifications *int64     `json:"unreadNotifications"`
	BackgroundColor     *string    `json:"backgroundColor"`
	InsertedAt          *string    `json:"insertedAt"`
	UpdatedAt           *string    `json:"updatedAt"`
}

type UserAttributes struct {
	Name     *string             `json:"name,omitempty"`
	Email    *string             `json:"email,omitempty"`
	Password *string             `json:"password,omitempty"`
	Roles    *UserRoleAttributes `json:"roles,omitempty"`
}

type UserConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*UserEdge `json:"edges"`
}

type UserEdge struct {
	Node   *User   `json:"node"`
	Cursor *string `json:"cursor"`
}

type UserRoleAttributes struct {
	Admin *bool `json:"admin,omitempty"`
}

type UserRoles struct {
	Admin *bool `json:"admin"`
}

// a shortform reference to an addon by version
type VersionReference struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type VerticalPodAutoscaler struct {
	Metadata Metadata                     `json:"metadata"`
	Spec     VerticalPodAutoscalerSpec    `json:"spec"`
	Status   *VerticalPodAutoscalerStatus `json:"status"`
}

type VerticalPodAutoscalerSpec struct {
	TargetRef    CrossVersionResourceTarget        `json:"targetRef"`
	UpdatePolicy VerticalPodAutoscalerUpdatePolicy `json:"updatePolicy"`
}

type VerticalPodAutoscalerStatus struct {
	Recommendation *Recommendation `json:"recommendation"`
}

type VerticalPodAutoscalerUpdatePolicy struct {
	UpdateMode *string `json:"updateMode"`
}

type WaitingState struct {
	Message *string `json:"message"`
	Reason  *string `json:"reason"`
}

type Webhook struct {
	ID         string        `json:"id"`
	URL        string        `json:"url"`
	Health     WebhookHealth `json:"health"`
	Type       WebhookType   `json:"type"`
	InsertedAt *string       `json:"insertedAt"`
	UpdatedAt  *string       `json:"updatedAt"`
}

type WebhookAttributes struct {
	URL string `json:"url"`
}

type WebhookConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*WebhookEdge `json:"edges"`
}

type WebhookEdge struct {
	Node   *Webhook `json:"node"`
	Cursor *string  `json:"cursor"`
}

type WireguardPeer struct {
	Metadata Metadata             `json:"metadata"`
	Status   *WireguardPeerStatus `json:"status"`
	Spec     WireguardPeerSpec    `json:"spec"`
	Config   *string              `json:"config"`
	User     *User                `json:"user"`
	Raw      string               `json:"raw"`
}

type WireguardPeerSpec struct {
	WireguardRef *string `json:"wireguardRef"`
	Address      *string `json:"address"`
	PublicKey    *string `json:"publicKey"`
}

type WireguardPeerStatus struct {
	Ready      *bool              `json:"ready"`
	Conditions []*StatusCondition `json:"conditions"`
}

type AuditAction string

const (
	AuditActionCreate  AuditAction = "CREATE"
	AuditActionUpdate  AuditAction = "UPDATE"
	AuditActionDelete  AuditAction = "DELETE"
	AuditActionApprove AuditAction = "APPROVE"
	AuditActionCancel  AuditAction = "CANCEL"
)

var AllAuditAction = []AuditAction{
	AuditActionCreate,
	AuditActionUpdate,
	AuditActionDelete,
	AuditActionApprove,
	AuditActionCancel,
}

func (e AuditAction) IsValid() bool {
	switch e {
	case AuditActionCreate, AuditActionUpdate, AuditActionDelete, AuditActionApprove, AuditActionCancel:
		return true
	}
	return false
}

func (e AuditAction) String() string {
	return string(e)
}

func (e *AuditAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditAction", str)
	}
	return nil
}

func (e AuditAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditType string

const (
	AuditTypeBuild              AuditType = "BUILD"
	AuditTypePod                AuditType = "POD"
	AuditTypeConfiguration      AuditType = "CONFIGURATION"
	AuditTypeUser               AuditType = "USER"
	AuditTypeGroup              AuditType = "GROUP"
	AuditTypeRole               AuditType = "ROLE"
	AuditTypeGroupMember        AuditType = "GROUP_MEMBER"
	AuditTypePolicy             AuditType = "POLICY"
	AuditTypeTempToken          AuditType = "TEMP_TOKEN"
	AuditTypeService            AuditType = "SERVICE"
	AuditTypeCluster            AuditType = "CLUSTER"
	AuditTypeClusterProvider    AuditType = "CLUSTER_PROVIDER"
	AuditTypeGitRepository      AuditType = "GIT_REPOSITORY"
	AuditTypeDeploymentSettings AuditType = "DEPLOYMENT_SETTINGS"
	AuditTypeProviderCredential AuditType = "PROVIDER_CREDENTIAL"
	AuditTypePipeline           AuditType = "PIPELINE"
	AuditTypeGlobal             AuditType = "GLOBAL"
)

var AllAuditType = []AuditType{
	AuditTypeBuild,
	AuditTypePod,
	AuditTypeConfiguration,
	AuditTypeUser,
	AuditTypeGroup,
	AuditTypeRole,
	AuditTypeGroupMember,
	AuditTypePolicy,
	AuditTypeTempToken,
	AuditTypeService,
	AuditTypeCluster,
	AuditTypeClusterProvider,
	AuditTypeGitRepository,
	AuditTypeDeploymentSettings,
	AuditTypeProviderCredential,
	AuditTypePipeline,
	AuditTypeGlobal,
}

func (e AuditType) IsValid() bool {
	switch e {
	case AuditTypeBuild, AuditTypePod, AuditTypeConfiguration, AuditTypeUser, AuditTypeGroup, AuditTypeRole, AuditTypeGroupMember, AuditTypePolicy, AuditTypeTempToken, AuditTypeService, AuditTypeCluster, AuditTypeClusterProvider, AuditTypeGitRepository, AuditTypeDeploymentSettings, AuditTypeProviderCredential, AuditTypePipeline, AuditTypeGlobal:
		return true
	}
	return false
}

func (e AuditType) String() string {
	return string(e)
}

func (e *AuditType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditType", str)
	}
	return nil
}

func (e AuditType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuthMethod string

const (
	AuthMethodBasic AuthMethod = "BASIC"
	AuthMethodSSH   AuthMethod = "SSH"
)

var AllAuthMethod = []AuthMethod{
	AuthMethodBasic,
	AuthMethodSSH,
}

func (e AuthMethod) IsValid() bool {
	switch e {
	case AuthMethodBasic, AuthMethodSSH:
		return true
	}
	return false
}

func (e AuthMethod) String() string {
	return string(e)
}

func (e *AuthMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthMethod", str)
	}
	return nil
}

func (e AuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AutoscalingTarget string

const (
	AutoscalingTargetStatefulset AutoscalingTarget = "STATEFULSET"
	AutoscalingTargetDeployment  AutoscalingTarget = "DEPLOYMENT"
)

var AllAutoscalingTarget = []AutoscalingTarget{
	AutoscalingTargetStatefulset,
	AutoscalingTargetDeployment,
}

func (e AutoscalingTarget) IsValid() bool {
	switch e {
	case AutoscalingTargetStatefulset, AutoscalingTargetDeployment:
		return true
	}
	return false
}

func (e AutoscalingTarget) String() string {
	return string(e)
}

func (e *AutoscalingTarget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutoscalingTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutoscalingTarget", str)
	}
	return nil
}

func (e AutoscalingTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BuildType string

const (
	BuildTypeDeploy    BuildType = "DEPLOY"
	BuildTypeBounce    BuildType = "BOUNCE"
	BuildTypeApproval  BuildType = "APPROVAL"
	BuildTypeInstall   BuildType = "INSTALL"
	BuildTypeDestroy   BuildType = "DESTROY"
	BuildTypeDedicated BuildType = "DEDICATED"
	BuildTypeConfig    BuildType = "CONFIG"
)

var AllBuildType = []BuildType{
	BuildTypeDeploy,
	BuildTypeBounce,
	BuildTypeApproval,
	BuildTypeInstall,
	BuildTypeDestroy,
	BuildTypeDedicated,
	BuildTypeConfig,
}

func (e BuildType) IsValid() bool {
	switch e {
	case BuildTypeDeploy, BuildTypeBounce, BuildTypeApproval, BuildTypeInstall, BuildTypeDestroy, BuildTypeDedicated, BuildTypeConfig:
		return true
	}
	return false
}

func (e BuildType) String() string {
	return string(e)
}

func (e *BuildType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BuildType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BuildType", str)
	}
	return nil
}

func (e BuildType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComponentState string

const (
	ComponentStateRunning ComponentState = "RUNNING"
	ComponentStatePending ComponentState = "PENDING"
	ComponentStateFailed  ComponentState = "FAILED"
)

var AllComponentState = []ComponentState{
	ComponentStateRunning,
	ComponentStatePending,
	ComponentStateFailed,
}

func (e ComponentState) IsValid() bool {
	switch e {
	case ComponentStateRunning, ComponentStatePending, ComponentStateFailed:
		return true
	}
	return false
}

func (e ComponentState) String() string {
	return string(e)
}

func (e *ComponentState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComponentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComponentState", str)
	}
	return nil
}

func (e ComponentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Delta string

const (
	DeltaCreate Delta = "CREATE"
	DeltaUpdate Delta = "UPDATE"
	DeltaDelete Delta = "DELETE"
)

var AllDelta = []Delta{
	DeltaCreate,
	DeltaUpdate,
	DeltaDelete,
}

func (e Delta) IsValid() bool {
	switch e {
	case DeltaCreate, DeltaUpdate, DeltaDelete:
		return true
	}
	return false
}

func (e Delta) String() string {
	return string(e)
}

func (e *Delta) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Delta(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Delta", str)
	}
	return nil
}

func (e Delta) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateState string

const (
	GateStatePending GateState = "PENDING"
	GateStateOpen    GateState = "OPEN"
	GateStateClosed  GateState = "CLOSED"
)

var AllGateState = []GateState{
	GateStatePending,
	GateStateOpen,
	GateStateClosed,
}

func (e GateState) IsValid() bool {
	switch e {
	case GateStatePending, GateStateOpen, GateStateClosed:
		return true
	}
	return false
}

func (e GateState) String() string {
	return string(e)
}

func (e *GateState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateState", str)
	}
	return nil
}

func (e GateState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateType string

const (
	GateTypeApproval GateType = "APPROVAL"
	GateTypeWindow   GateType = "WINDOW"
	GateTypeJob      GateType = "JOB"
)

var AllGateType = []GateType{
	GateTypeApproval,
	GateTypeWindow,
	GateTypeJob,
}

func (e GateType) IsValid() bool {
	switch e {
	case GateTypeApproval, GateTypeWindow, GateTypeJob:
		return true
	}
	return false
}

func (e GateType) String() string {
	return string(e)
}

func (e *GateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateType", str)
	}
	return nil
}

func (e GateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GitHealth string

const (
	GitHealthPullable GitHealth = "PULLABLE"
	GitHealthFailed   GitHealth = "FAILED"
)

var AllGitHealth = []GitHealth{
	GitHealthPullable,
	GitHealthFailed,
}

func (e GitHealth) IsValid() bool {
	switch e {
	case GitHealthPullable, GitHealthFailed:
		return true
	}
	return false
}

func (e GitHealth) String() string {
	return string(e)
}

func (e *GitHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitHealth", str)
	}
	return nil
}

func (e GitHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationStatus string

const (
	NotificationStatusFiring   NotificationStatus = "FIRING"
	NotificationStatusResolved NotificationStatus = "RESOLVED"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusFiring,
	NotificationStatusResolved,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusFiring, NotificationStatusResolved:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Permission string

const (
	PermissionRead      Permission = "READ"
	PermissionConfigure Permission = "CONFIGURE"
	PermissionDeploy    Permission = "DEPLOY"
	PermissionOperate   Permission = "OPERATE"
)

var AllPermission = []Permission{
	PermissionRead,
	PermissionConfigure,
	PermissionDeploy,
	PermissionOperate,
}

func (e Permission) IsValid() bool {
	switch e {
	case PermissionRead, PermissionConfigure, PermissionDeploy, PermissionOperate:
		return true
	}
	return false
}

func (e Permission) String() string {
	return string(e)
}

func (e *Permission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Permission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Permission", str)
	}
	return nil
}

func (e Permission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReadType string

const (
	ReadTypeNotification ReadType = "NOTIFICATION"
	ReadTypeBuild        ReadType = "BUILD"
)

var AllReadType = []ReadType{
	ReadTypeNotification,
	ReadTypeBuild,
}

func (e ReadType) IsValid() bool {
	switch e {
	case ReadTypeNotification, ReadTypeBuild:
		return true
	}
	return false
}

func (e ReadType) String() string {
	return string(e)
}

func (e *ReadType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReadType", str)
	}
	return nil
}

func (e ReadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceDeploymentStatus string

const (
	ServiceDeploymentStatusStale   ServiceDeploymentStatus = "STALE"
	ServiceDeploymentStatusSynced  ServiceDeploymentStatus = "SYNCED"
	ServiceDeploymentStatusHealthy ServiceDeploymentStatus = "HEALTHY"
	ServiceDeploymentStatusFailed  ServiceDeploymentStatus = "FAILED"
)

var AllServiceDeploymentStatus = []ServiceDeploymentStatus{
	ServiceDeploymentStatusStale,
	ServiceDeploymentStatusSynced,
	ServiceDeploymentStatusHealthy,
	ServiceDeploymentStatusFailed,
}

func (e ServiceDeploymentStatus) IsValid() bool {
	switch e {
	case ServiceDeploymentStatusStale, ServiceDeploymentStatusSynced, ServiceDeploymentStatusHealthy, ServiceDeploymentStatusFailed:
		return true
	}
	return false
}

func (e ServiceDeploymentStatus) String() string {
	return string(e)
}

func (e *ServiceDeploymentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceDeploymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceDeploymentStatus", str)
	}
	return nil
}

func (e ServiceDeploymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Severity string

const (
	SeverityNone     Severity = "NONE"
	SeverityLow      Severity = "LOW"
	SeverityMedium   Severity = "MEDIUM"
	SeverityHigh     Severity = "HIGH"
	SeverityCritical Severity = "CRITICAL"
)

var AllSeverity = []Severity{
	SeverityNone,
	SeverityLow,
	SeverityMedium,
	SeverityHigh,
	SeverityCritical,
}

func (e Severity) IsValid() bool {
	switch e {
	case SeverityNone, SeverityLow, SeverityMedium, SeverityHigh, SeverityCritical:
		return true
	}
	return false
}

func (e Severity) String() string {
	return string(e)
}

func (e *Severity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Severity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Severity", str)
	}
	return nil
}

func (e Severity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusQueued     Status = "QUEUED"
	StatusRunning    Status = "RUNNING"
	StatusSuccessful Status = "SUCCESSFUL"
	StatusFailed     Status = "FAILED"
	StatusCancelled  Status = "CANCELLED"
	StatusPending    Status = "PENDING"
)

var AllStatus = []Status{
	StatusQueued,
	StatusRunning,
	StatusSuccessful,
	StatusFailed,
	StatusCancelled,
	StatusPending,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusQueued, StatusRunning, StatusSuccessful, StatusFailed, StatusCancelled, StatusPending:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Tool string

const (
	ToolHelm      Tool = "HELM"
	ToolTerraform Tool = "TERRAFORM"
)

var AllTool = []Tool{
	ToolHelm,
	ToolTerraform,
}

func (e Tool) IsValid() bool {
	switch e {
	case ToolHelm, ToolTerraform:
		return true
	}
	return false
}

func (e Tool) String() string {
	return string(e)
}

func (e *Tool) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Tool(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Tool", str)
	}
	return nil
}

func (e Tool) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpgradePolicyType string

const (
	UpgradePolicyTypeDeploy   UpgradePolicyType = "DEPLOY"
	UpgradePolicyTypeApproval UpgradePolicyType = "APPROVAL"
	UpgradePolicyTypeIgnore   UpgradePolicyType = "IGNORE"
)

var AllUpgradePolicyType = []UpgradePolicyType{
	UpgradePolicyTypeDeploy,
	UpgradePolicyTypeApproval,
	UpgradePolicyTypeIgnore,
}

func (e UpgradePolicyType) IsValid() bool {
	switch e {
	case UpgradePolicyTypeDeploy, UpgradePolicyTypeApproval, UpgradePolicyTypeIgnore:
		return true
	}
	return false
}

func (e UpgradePolicyType) String() string {
	return string(e)
}

func (e *UpgradePolicyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePolicyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePolicyType", str)
	}
	return nil
}

func (e UpgradePolicyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookHealth string

const (
	WebhookHealthHealthy   WebhookHealth = "HEALTHY"
	WebhookHealthUnhealthy WebhookHealth = "UNHEALTHY"
)

var AllWebhookHealth = []WebhookHealth{
	WebhookHealthHealthy,
	WebhookHealthUnhealthy,
}

func (e WebhookHealth) IsValid() bool {
	switch e {
	case WebhookHealthHealthy, WebhookHealthUnhealthy:
		return true
	}
	return false
}

func (e WebhookHealth) String() string {
	return string(e)
}

func (e *WebhookHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookHealth", str)
	}
	return nil
}

func (e WebhookHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookType string

const (
	WebhookTypePiazza WebhookType = "PIAZZA"
	WebhookTypeSLACk  WebhookType = "SLACK"
)

var AllWebhookType = []WebhookType{
	WebhookTypePiazza,
	WebhookTypeSLACk,
}

func (e WebhookType) IsValid() bool {
	switch e {
	case WebhookTypePiazza, WebhookTypeSLACk:
		return true
	}
	return false
}

func (e WebhookType) String() string {
	return string(e)
}

func (e *WebhookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookType", str)
	}
	return nil
}

func (e WebhookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
