// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package gqlclient

import (
	"context"
	"net/http"

	"github.com/Yamashou/gqlgenc/client"
)

type Client struct {
	Client *client.Client
}

func NewClient(cli *http.Client, baseURL string, options ...client.HTTPRequestOption) *Client {
	return &Client{Client: client.NewClient(cli, baseURL, options...)}
}

type RootQueryType struct {
	Configuration           *ConsoleConfiguration        "json:\"configuration\" graphql:\"configuration\""
	ExternalToken           *string                      "json:\"externalToken\" graphql:\"externalToken\""
	Builds                  *BuildConnection             "json:\"builds\" graphql:\"builds\""
	Build                   *Build                       "json:\"build\" graphql:\"build\""
	BuildInfo               *BuildInfo                   "json:\"buildInfo\" graphql:\"buildInfo\""
	User                    *User                        "json:\"user\" graphql:\"user\""
	Group                   *Group                       "json:\"group\" graphql:\"group\""
	Users                   *UserConnection              "json:\"users\" graphql:\"users\""
	ServiceAccounts         *UserConnection              "json:\"serviceAccounts\" graphql:\"serviceAccounts\""
	LoginInfo               *LoginInfo                   "json:\"loginInfo\" graphql:\"loginInfo\""
	Me                      *User                        "json:\"me\" graphql:\"me\""
	Invite                  *Invite                      "json:\"invite\" graphql:\"invite\""
	Groups                  *GroupConnection             "json:\"groups\" graphql:\"groups\""
	GroupMembers            *GroupMemberConnection       "json:\"groupMembers\" graphql:\"groupMembers\""
	Role                    *Role                        "json:\"role\" graphql:\"role\""
	Roles                   *RoleConnection              "json:\"roles\" graphql:\"roles\""
	Notifications           *NotificationConnection      "json:\"notifications\" graphql:\"notifications\""
	TemporaryToken          *string                      "json:\"temporaryToken\" graphql:\"temporaryToken\""
	AccessTokens            *AccessTokenConnection       "json:\"accessTokens\" graphql:\"accessTokens\""
	AccessToken             *AccessToken                 "json:\"accessToken\" graphql:\"accessToken\""
	Dashboards              []*Dashboard                 "json:\"dashboards\" graphql:\"dashboards\""
	Dashboard               *Dashboard                   "json:\"dashboard\" graphql:\"dashboard\""
	Metric                  []*MetricResponse            "json:\"metric\" graphql:\"metric\""
	Logs                    []*LogStream                 "json:\"logs\" graphql:\"logs\""
	ScalingRecommendation   *VerticalPodAutoscaler       "json:\"scalingRecommendation\" graphql:\"scalingRecommendation\""
	ConfigMap               *ConfigMap                   "json:\"configMap\" graphql:\"configMap\""
	Secret                  *Secret                      "json:\"secret\" graphql:\"secret\""
	ConfigMaps              []*ConfigMap                 "json:\"configMaps\" graphql:\"configMaps\""
	Secrets                 []*Secret                    "json:\"secrets\" graphql:\"secrets\""
	PluralCluster           *PluralCluster               "json:\"pluralCluster\" graphql:\"pluralCluster\""
	PluralServiceDeployment *PluralServiceDeployment     "json:\"pluralServiceDeployment\" graphql:\"pluralServiceDeployment\""
	PluralGitRepository     *PluralGitRepository         "json:\"pluralGitRepository\" graphql:\"pluralGitRepository\""
	UnstructuredResource    *KubernetesUnstructured      "json:\"unstructuredResource\" graphql:\"unstructuredResource\""
	Service                 *Service                     "json:\"service\" graphql:\"service\""
	ClusterInfo             *ClusterInfo                 "json:\"clusterInfo\" graphql:\"clusterInfo\""
	Deployment              *Deployment                  "json:\"deployment\" graphql:\"deployment\""
	StatefulSet             *StatefulSet                 "json:\"statefulSet\" graphql:\"statefulSet\""
	DaemonSet               *DaemonSet                   "json:\"daemonSet\" graphql:\"daemonSet\""
	Ingress                 *Ingress                     "json:\"ingress\" graphql:\"ingress\""
	Nodes                   []*Node                      "json:\"nodes\" graphql:\"nodes\""
	Node                    *Node                        "json:\"node\" graphql:\"node\""
	CronJob                 *CronJob                     "json:\"cronJob\" graphql:\"cronJob\""
	Job                     *Job                         "json:\"job\" graphql:\"job\""
	Certificate             *Certificate                 "json:\"certificate\" graphql:\"certificate\""
	Pod                     *Pod                         "json:\"pod\" graphql:\"pod\""
	Pods                    *PodConnection               "json:\"pods\" graphql:\"pods\""
	WireguardPeers          []*WireguardPeer             "json:\"wireguardPeers\" graphql:\"wireguardPeers\""
	MyWireguardPeers        []*WireguardPeer             "json:\"myWireguardPeers\" graphql:\"myWireguardPeers\""
	WireguardPeer           *WireguardPeer               "json:\"wireguardPeer\" graphql:\"wireguardPeer\""
	CachedPods              []*Pod                       "json:\"cachedPods\" graphql:\"cachedPods\""
	Namespaces              []*Namespace                 "json:\"namespaces\" graphql:\"namespaces\""
	LogFilters              []*LogFilter                 "json:\"logFilters\" graphql:\"logFilters\""
	NodeMetrics             []*NodeMetric                "json:\"nodeMetrics\" graphql:\"nodeMetrics\""
	NodeMetric              *NodeMetric                  "json:\"nodeMetric\" graphql:\"nodeMetric\""
	Canary                  *Canary                      "json:\"canary\" graphql:\"canary\""
	UpgradePlan             *UpgradePlan                 "json:\"upgradePlan\" graphql:\"upgradePlan\""
	ConfigurationOverlays   []*ConfigurationOverlay      "json:\"configurationOverlays\" graphql:\"configurationOverlays\""
	Audits                  *AuditConnection             "json:\"audits\" graphql:\"audits\""
	AuditMetrics            []*AuditMetric               "json:\"auditMetrics\" graphql:\"auditMetrics\""
	Ai                      *string                      "json:\"ai\" graphql:\"ai\""
	Account                 *Account                     "json:\"account\" graphql:\"account\""
	Installations           *InstallationConnection      "json:\"installations\" graphql:\"installations\""
	Applications            []*Application               "json:\"applications\" graphql:\"applications\""
	Application             *Application                 "json:\"application\" graphql:\"application\""
	Repository              *Repository                  "json:\"repository\" graphql:\"repository\""
	Repositories            *RepositoryConnection        "json:\"repositories\" graphql:\"repositories\""
	Recipes                 *RecipeConnection            "json:\"recipes\" graphql:\"recipes\""
	Context                 []*RepositoryContext         "json:\"context\" graphql:\"context\""
	PluralContext           *PluralContext               "json:\"pluralContext\" graphql:\"pluralContext\""
	Recipe                  *Recipe                      "json:\"recipe\" graphql:\"recipe\""
	Stack                   *Stack                       "json:\"stack\" graphql:\"stack\""
	SMTP                    *SMTP                        "json:\"smtp\" graphql:\"smtp\""
	UpgradePolicies         []*UpgradePolicy             "json:\"upgradePolicies\" graphql:\"upgradePolicies\""
	Runbook                 *Runbook                     "json:\"runbook\" graphql:\"runbook\""
	Runbooks                []*Runbook                   "json:\"runbooks\" graphql:\"runbooks\""
	Webhooks                *WebhookConnection           "json:\"webhooks\" graphql:\"webhooks\""
	PostgresDatabases       []*Postgresql                "json:\"postgresDatabases\" graphql:\"postgresDatabases\""
	PostgresDatabase        *Postgresql                  "json:\"postgresDatabase\" graphql:\"postgresDatabase\""
	GitRepository           *GitRepository               "json:\"gitRepository\" graphql:\"gitRepository\""
	GitRepositories         *GitRepositoryConnection     "json:\"gitRepositories\" graphql:\"gitRepositories\""
	HelmRepositories        []*HelmRepository            "json:\"helmRepositories\" graphql:\"helmRepositories\""
	HelmRepository          *HelmRepository              "json:\"helmRepository\" graphql:\"helmRepository\""
	TokenExchange           *User                        "json:\"tokenExchange\" graphql:\"tokenExchange\""
	Clusters                *ClusterConnection           "json:\"clusters\" graphql:\"clusters\""
	ClusterStatuses         []*ClusterStatusInfo         "json:\"clusterStatuses\" graphql:\"clusterStatuses\""
	Tags                    []*string                    "json:\"tags\" graphql:\"tags\""
	ClusterProviders        *ClusterProviderConnection   "json:\"clusterProviders\" graphql:\"clusterProviders\""
	Cluster                 *Cluster                     "json:\"cluster\" graphql:\"cluster\""
	ClusterProvider         *ClusterProvider             "json:\"clusterProvider\" graphql:\"clusterProvider\""
	ClusterAddOns           []*ClusterAddOn              "json:\"clusterAddOns\" graphql:\"clusterAddOns\""
	RuntimeService          *RuntimeService              "json:\"runtimeService\" graphql:\"runtimeService\""
	ServiceDeployments      *ServiceDeploymentConnection "json:\"serviceDeployments\" graphql:\"serviceDeployments\""
	ServiceStatuses         []*ServiceStatusCount        "json:\"serviceStatuses\" graphql:\"serviceStatuses\""
	GlobalService           *GlobalService               "json:\"globalService\" graphql:\"globalService\""
	Pipelines               *PipelineConnection          "json:\"pipelines\" graphql:\"pipelines\""
	Pipeline                *Pipeline                    "json:\"pipeline\" graphql:\"pipeline\""
	ClusterServices         []*ServiceDeployment         "json:\"clusterServices\" graphql:\"clusterServices\""
	ServiceDeployment       *ServiceDeployment           "json:\"serviceDeployment\" graphql:\"serviceDeployment\""
	MyCluster               *Cluster                     "json:\"myCluster\" graphql:\"myCluster\""
	ClusterGates            []*PipelineGate              "json:\"clusterGates\" graphql:\"clusterGates\""
	DeploymentSettings      *DeploymentSettings          "json:\"deploymentSettings\" graphql:\"deploymentSettings\""
}
type RootMutationType struct {
	CreateBuild               *Build                 "json:\"createBuild\" graphql:\"createBuild\""
	RestartBuild              *Build                 "json:\"restartBuild\" graphql:\"restartBuild\""
	CancelBuild               *Build                 "json:\"cancelBuild\" graphql:\"cancelBuild\""
	ApproveBuild              *Build                 "json:\"approveBuild\" graphql:\"approveBuild\""
	SignIn                    *User                  "json:\"signIn\" graphql:\"signIn\""
	LoginLink                 *User                  "json:\"loginLink\" graphql:\"loginLink\""
	ReadNotifications         *User                  "json:\"readNotifications\" graphql:\"readNotifications\""
	Signup                    *User                  "json:\"signup\" graphql:\"signup\""
	OauthCallback             *User                  "json:\"oauthCallback\" graphql:\"oauthCallback\""
	CreateInvite              *Invite                "json:\"createInvite\" graphql:\"createInvite\""
	CreateServiceAccount      *User                  "json:\"createServiceAccount\" graphql:\"createServiceAccount\""
	UpdateServiceAccount      *User                  "json:\"updateServiceAccount\" graphql:\"updateServiceAccount\""
	UpdateUser                *User                  "json:\"updateUser\" graphql:\"updateUser\""
	DeleteUser                *User                  "json:\"deleteUser\" graphql:\"deleteUser\""
	MarkRead                  *User                  "json:\"markRead\" graphql:\"markRead\""
	CreateGroup               *Group                 "json:\"createGroup\" graphql:\"createGroup\""
	DeleteGroup               *Group                 "json:\"deleteGroup\" graphql:\"deleteGroup\""
	UpdateGroup               *Group                 "json:\"updateGroup\" graphql:\"updateGroup\""
	CreateGroupMember         *GroupMember           "json:\"createGroupMember\" graphql:\"createGroupMember\""
	DeleteGroupMember         *GroupMember           "json:\"deleteGroupMember\" graphql:\"deleteGroupMember\""
	CreateRole                *Role                  "json:\"createRole\" graphql:\"createRole\""
	UpdateRole                *Role                  "json:\"updateRole\" graphql:\"updateRole\""
	DeleteRole                *Role                  "json:\"deleteRole\" graphql:\"deleteRole\""
	CreateAccessToken         *AccessToken           "json:\"createAccessToken\" graphql:\"createAccessToken\""
	CreateServiceAccountToken *AccessToken           "json:\"createServiceAccountToken\" graphql:\"createServiceAccountToken\""
	DeleteAccessToken         *AccessToken           "json:\"deleteAccessToken\" graphql:\"deleteAccessToken\""
	DeleteCertificate         *bool                  "json:\"deleteCertificate\" graphql:\"deleteCertificate\""
	DeletePod                 *Pod                   "json:\"deletePod\" graphql:\"deletePod\""
	DeleteJob                 *Job                   "json:\"deleteJob\" graphql:\"deleteJob\""
	DeleteNode                *Node                  "json:\"deleteNode\" graphql:\"deleteNode\""
	OverlayConfiguration      *Build                 "json:\"overlayConfiguration\" graphql:\"overlayConfiguration\""
	CreatePeer                *WireguardPeer         "json:\"createPeer\" graphql:\"createPeer\""
	DeletePeer                *bool                  "json:\"deletePeer\" graphql:\"deletePeer\""
	InstallRecipe             *Build                 "json:\"installRecipe\" graphql:\"installRecipe\""
	InstallStack              *Build                 "json:\"installStack\" graphql:\"installStack\""
	UpdateSMTP                *SMTP                  "json:\"updateSmtp\" graphql:\"updateSmtp\""
	UpdateConfiguration       *Configuration         "json:\"updateConfiguration\" graphql:\"updateConfiguration\""
	CreateUpgradePolicy       *UpgradePolicy         "json:\"createUpgradePolicy\" graphql:\"createUpgradePolicy\""
	DeleteUpgradePolicy       *UpgradePolicy         "json:\"deleteUpgradePolicy\" graphql:\"deleteUpgradePolicy\""
	ExecuteRunbook            *RunbookActionResponse "json:\"executeRunbook\" graphql:\"executeRunbook\""
	CreateWebhook             *Webhook               "json:\"createWebhook\" graphql:\"createWebhook\""
	DeleteWebhook             *Webhook               "json:\"deleteWebhook\" graphql:\"deleteWebhook\""
	RestorePostgres           *Postgresql            "json:\"restorePostgres\" graphql:\"restorePostgres\""
	CreateGitRepository       *GitRepository         "json:\"createGitRepository\" graphql:\"createGitRepository\""
	UpdateGitRepository       *GitRepository         "json:\"updateGitRepository\" graphql:\"updateGitRepository\""
	DeleteGitRepository       *GitRepository         "json:\"deleteGitRepository\" graphql:\"deleteGitRepository\""
	CreateCluster             *Cluster               "json:\"createCluster\" graphql:\"createCluster\""
	UpdateCluster             *Cluster               "json:\"updateCluster\" graphql:\"updateCluster\""
	DeleteCluster             *Cluster               "json:\"deleteCluster\" graphql:\"deleteCluster\""
	DetachCluster             *Cluster               "json:\"detachCluster\" graphql:\"detachCluster\""
	CreateClusterProvider     *ClusterProvider       "json:\"createClusterProvider\" graphql:\"createClusterProvider\""
	UpdateClusterProvider     *ClusterProvider       "json:\"updateClusterProvider\" graphql:\"updateClusterProvider\""
	DeleteClusterProvider     *ClusterProvider       "json:\"deleteClusterProvider\" graphql:\"deleteClusterProvider\""
	CreateProviderCredential  *ProviderCredential    "json:\"createProviderCredential\" graphql:\"createProviderCredential\""
	DeleteProviderCredential  *ProviderCredential    "json:\"deleteProviderCredential\" graphql:\"deleteProviderCredential\""
	InstallAddOn              *ServiceDeployment     "json:\"installAddOn\" graphql:\"installAddOn\""
	CreateAgentMigration      *AgentMigration        "json:\"createAgentMigration\" graphql:\"createAgentMigration\""
	CreateServiceDeployment   *ServiceDeployment     "json:\"createServiceDeployment\" graphql:\"createServiceDeployment\""
	UpdateServiceDeployment   *ServiceDeployment     "json:\"updateServiceDeployment\" graphql:\"updateServiceDeployment\""
	DeleteServiceDeployment   *ServiceDeployment     "json:\"deleteServiceDeployment\" graphql:\"deleteServiceDeployment\""
	MergeService              *ServiceDeployment     "json:\"mergeService\" graphql:\"mergeService\""
	RollbackService           *ServiceDeployment     "json:\"rollbackService\" graphql:\"rollbackService\""
	CloneService              *ServiceDeployment     "json:\"cloneService\" graphql:\"cloneService\""
	SelfManage                *ServiceDeployment     "json:\"selfManage\" graphql:\"selfManage\""
	Proceed                   *ServiceDeployment     "json:\"proceed\" graphql:\"proceed\""
	CreateGlobalService       *GlobalService         "json:\"createGlobalService\" graphql:\"createGlobalService\""
	UpdateGlobalService       *GlobalService         "json:\"updateGlobalService\" graphql:\"updateGlobalService\""
	DeleteGlobalService       *GlobalService         "json:\"deleteGlobalService\" graphql:\"deleteGlobalService\""
	SavePipeline              *Pipeline              "json:\"savePipeline\" graphql:\"savePipeline\""
	DeletePipeline            *Pipeline              "json:\"deletePipeline\" graphql:\"deletePipeline\""
	ApproveGate               *PipelineGate          "json:\"approveGate\" graphql:\"approveGate\""
	ForceGate                 *PipelineGate          "json:\"forceGate\" graphql:\"forceGate\""
	PingCluster               *Cluster               "json:\"pingCluster\" graphql:\"pingCluster\""
	RegisterRuntimeServices   *int64                 "json:\"registerRuntimeServices\" graphql:\"registerRuntimeServices\""
	UpdateServiceComponents   *ServiceDeployment     "json:\"updateServiceComponents\" graphql:\"updateServiceComponents\""
	UpdateGate                *PipelineGate          "json:\"updateGate\" graphql:\"updateGate\""
	UpdateRbac                *bool                  "json:\"updateRbac\" graphql:\"updateRbac\""
	UpdateDeploymentSettings  *DeploymentSettings    "json:\"updateDeploymentSettings\" graphql:\"updateDeploymentSettings\""
	EnableDeployments         *DeploymentSettings    "json:\"enableDeployments\" graphql:\"enableDeployments\""
}
type AccessTokenEdgeFragment struct {
	Node *AccessTokenFragment "json:\"node\" graphql:\"node\""
}
type AccessTokenFragment struct {
	ID    *string "json:\"id\" graphql:\"id\""
	Token *string "json:\"token\" graphql:\"token\""
}
type BaseClusterFragment struct {
	ID             string                       "json:\"id\" graphql:\"id\""
	Name           string                       "json:\"name\" graphql:\"name\""
	Handle         *string                      "json:\"handle\" graphql:\"handle\""
	Self           *bool                        "json:\"self\" graphql:\"self\""
	Version        *string                      "json:\"version\" graphql:\"version\""
	PingedAt       *string                      "json:\"pingedAt\" graphql:\"pingedAt\""
	CurrentVersion *string                      "json:\"currentVersion\" graphql:\"currentVersion\""
	KasURL         *string                      "json:\"kasUrl\" graphql:\"kasUrl\""
	Credential     *ProviderCredentialFragment  "json:\"credential\" graphql:\"credential\""
	Provider       *BaseClusterProviderFragment "json:\"provider\" graphql:\"provider\""
	NodePools      []*NodePoolFragment          "json:\"nodePools\" graphql:\"nodePools\""
}
type BaseClusterProviderFragment struct {
	ID         string                 "json:\"id\" graphql:\"id\""
	Name       string                 "json:\"name\" graphql:\"name\""
	Namespace  string                 "json:\"namespace\" graphql:\"namespace\""
	Cloud      string                 "json:\"cloud\" graphql:\"cloud\""
	Editable   *bool                  "json:\"editable\" graphql:\"editable\""
	Repository *GitRepositoryFragment "json:\"repository\" graphql:\"repository\""
}
type ClusterConditionFragment struct {
	LastTransitionTime *string "json:\"lastTransitionTime\" graphql:\"lastTransitionTime\""
	Status             *string "json:\"status\" graphql:\"status\""
	Type               *string "json:\"type\" graphql:\"type\""
	Message            *string "json:\"message\" graphql:\"message\""
	Reason             *string "json:\"reason\" graphql:\"reason\""
	Severity           *string "json:\"severity\" graphql:\"severity\""
}
type ClusterEdgeFragment struct {
	Node *ClusterFragment "json:\"node\" graphql:\"node\""
}
type ClusterFragment struct {
	ID             string                      "json:\"id\" graphql:\"id\""
	Name           string                      "json:\"name\" graphql:\"name\""
	Handle         *string                     "json:\"handle\" graphql:\"handle\""
	Self           *bool                       "json:\"self\" graphql:\"self\""
	Version        *string                     "json:\"version\" graphql:\"version\""
	InsertedAt     *string                     "json:\"insertedAt\" graphql:\"insertedAt\""
	PingedAt       *string                     "json:\"pingedAt\" graphql:\"pingedAt\""
	Protect        *bool                       "json:\"protect\" graphql:\"protect\""
	CurrentVersion *string                     "json:\"currentVersion\" graphql:\"currentVersion\""
	KasURL         *string                     "json:\"kasUrl\" graphql:\"kasUrl\""
	DeletedAt      *string                     "json:\"deletedAt\" graphql:\"deletedAt\""
	Tags           []*ClusterTags              "json:\"tags\" graphql:\"tags\""
	Credential     *ProviderCredentialFragment "json:\"credential\" graphql:\"credential\""
	Provider       *ClusterProviderFragment    "json:\"provider\" graphql:\"provider\""
	NodePools      []*NodePoolFragment         "json:\"nodePools\" graphql:\"nodePools\""
	Status         *ClusterStatusFragment      "json:\"status\" graphql:\"status\""
}
type ClusterProviderConnectionFragment struct {
	Edges []*ClusterProviderEdgeFragment "json:\"edges\" graphql:\"edges\""
}
type ClusterProviderEdgeFragment struct {
	Node *ClusterProviderFragment "json:\"node\" graphql:\"node\""
}
type ClusterProviderFragment struct {
	ID          string                        "json:\"id\" graphql:\"id\""
	Name        string                        "json:\"name\" graphql:\"name\""
	Namespace   string                        "json:\"namespace\" graphql:\"namespace\""
	Cloud       string                        "json:\"cloud\" graphql:\"cloud\""
	Editable    *bool                         "json:\"editable\" graphql:\"editable\""
	DeletedAt   *string                       "json:\"deletedAt\" graphql:\"deletedAt\""
	Repository  *GitRepositoryFragment        "json:\"repository\" graphql:\"repository\""
	Service     *ServiceDeploymentFragment    "json:\"service\" graphql:\"service\""
	Credentials []*ProviderCredentialFragment "json:\"credentials\" graphql:\"credentials\""
}
type ClusterStatusFragment struct {
	Conditions        []*ClusterConditionFragment "json:\"conditions\" graphql:\"conditions\""
	ControlPlaneReady *bool                       "json:\"controlPlaneReady\" graphql:\"controlPlaneReady\""
	FailureMessage    *string                     "json:\"failureMessage\" graphql:\"failureMessage\""
	FailureReason     *string                     "json:\"failureReason\" graphql:\"failureReason\""
	Phase             *string                     "json:\"phase\" graphql:\"phase\""
}
type ClusterTags struct {
	Name  string "json:\"name\" graphql:\"name\""
	Value string "json:\"value\" graphql:\"value\""
}
type ContainerSpecFragment struct {
	Image string    "json:\"image\" graphql:\"image\""
	Args  []*string "json:\"args\" graphql:\"args\""
	Env   []*struct {
		Name  string "json:\"name\" graphql:\"name\""
		Value string "json:\"value\" graphql:\"value\""
	} "json:\"env\" graphql:\"env\""
	EnvFrom []*struct {
		ConfigMap string "json:\"configMap\" graphql:\"configMap\""
		Secret    string "json:\"secret\" graphql:\"secret\""
	} "json:\"envFrom\" graphql:\"envFrom\""
}
type DeploymentSettingsFragment struct {
	ID                 string                   "json:\"id\" graphql:\"id\""
	Name               string                   "json:\"name\" graphql:\"name\""
	WriteBindings      []*PolicyBindingFragment "json:\"writeBindings\" graphql:\"writeBindings\""
	ReadBindings       []*PolicyBindingFragment "json:\"readBindings\" graphql:\"readBindings\""
	CreateBindings     []*PolicyBindingFragment "json:\"createBindings\" graphql:\"createBindings\""
	ArtifactRepository *GitRepositoryFragment   "json:\"artifactRepository\" graphql:\"artifactRepository\""
	DeployerRepository *GitRepositoryFragment   "json:\"deployerRepository\" graphql:\"deployerRepository\""
}
type ErrorFragment struct {
	Source  string "json:\"source\" graphql:\"source\""
	Message string "json:\"message\" graphql:\"message\""
}
type GateSpecFragment struct {
	Job *JobSpecFragment "json:\"job\" graphql:\"job\""
}
type GitRefFragment struct {
	Folder string "json:\"folder\" graphql:\"folder\""
	Ref    string "json:\"ref\" graphql:\"ref\""
}
type GitRepositoryEdgeFragment struct {
	Node   *GitRepositoryFragment "json:\"node\" graphql:\"node\""
	Cursor *string                "json:\"cursor\" graphql:\"cursor\""
}
type GitRepositoryFragment struct {
	ID         string      "json:\"id\" graphql:\"id\""
	Error      *string     "json:\"error\" graphql:\"error\""
	Health     *GitHealth  "json:\"health\" graphql:\"health\""
	AuthMethod *AuthMethod "json:\"authMethod\" graphql:\"authMethod\""
	URL        string      "json:\"url\" graphql:\"url\""
	Decrypt    *bool       "json:\"decrypt\" graphql:\"decrypt\""
}
type GlobalServiceFragment struct {
	ID       string         "json:\"id\" graphql:\"id\""
	Name     string         "json:\"name\" graphql:\"name\""
	Distro   *ClusterDistro "json:\"distro\" graphql:\"distro\""
	Provider *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"provider\" graphql:\"provider\""
	Service *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"service\" graphql:\"service\""
	Tags []*ClusterTags "json:\"tags\" graphql:\"tags\""
}
type GroupFragment struct {
	ID          string  "json:\"id\" graphql:\"id\""
	Name        string  "json:\"name\" graphql:\"name\""
	Description *string "json:\"description\" graphql:\"description\""
}
type GroupMemberFragment struct {
	ID   string "json:\"id\" graphql:\"id\""
	User *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"user\" graphql:\"user\""
	Group *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"group\" graphql:\"group\""
}
type HelmSpecFragment struct {
	ValuesFiles []*string "json:\"valuesFiles\" graphql:\"valuesFiles\""
}
type JobSpecFragment struct {
	Namespace      string                   "json:\"namespace\" graphql:\"namespace\""
	Raw            *string                  "json:\"raw\" graphql:\"raw\""
	Containers     []*ContainerSpecFragment "json:\"containers\" graphql:\"containers\""
	Labels         map[string]interface{}   "json:\"labels\" graphql:\"labels\""
	Annotations    map[string]interface{}   "json:\"annotations\" graphql:\"annotations\""
	ServiceAccount *string                  "json:\"serviceAccount\" graphql:\"serviceAccount\""
}
type KustomizeFragment struct {
	Path string "json:\"path\" graphql:\"path\""
}
type NodePoolFragment struct {
	ID           string                   "json:\"id\" graphql:\"id\""
	Name         string                   "json:\"name\" graphql:\"name\""
	MinSize      int64                    "json:\"minSize\" graphql:\"minSize\""
	MaxSize      int64                    "json:\"maxSize\" graphql:\"maxSize\""
	InstanceType string                   "json:\"instanceType\" graphql:\"instanceType\""
	Labels       map[string]interface{}   "json:\"labels\" graphql:\"labels\""
	Taints       []*NodePoolTaintFragment "json:\"taints\" graphql:\"taints\""
}
type NodePoolTaintFragment struct {
	Key    string "json:\"key\" graphql:\"key\""
	Value  string "json:\"value\" graphql:\"value\""
	Effect string "json:\"effect\" graphql:\"effect\""
}
type PipelineEdgeFragment struct {
	Node *PipelineFragment "json:\"node\" graphql:\"node\""
}
type PipelineFragment struct {
	ID     string                       "json:\"id\" graphql:\"id\""
	Name   string                       "json:\"name\" graphql:\"name\""
	Stages []*PipelineStageFragment     "json:\"stages\" graphql:\"stages\""
	Edges  []*PipelineStageEdgeFragment "json:\"edges\" graphql:\"edges\""
}
type PipelineGateFragment struct {
	ID        string            "json:\"id\" graphql:\"id\""
	Name      string            "json:\"name\" graphql:\"name\""
	Type      GateType          "json:\"type\" graphql:\"type\""
	State     GateState         "json:\"state\" graphql:\"state\""
	UpdatedAt *string           "json:\"updatedAt\" graphql:\"updatedAt\""
	Spec      *GateSpecFragment "json:\"spec\" graphql:\"spec\""
}
type PipelineStageEdgeFragment struct {
	ID   string                "json:\"id\" graphql:\"id\""
	From PipelineStageFragment "json:\"from\" graphql:\"from\""
	To   PipelineStageFragment "json:\"to\" graphql:\"to\""
}
type PipelineStageFragment struct {
	ID       string "json:\"id\" graphql:\"id\""
	Name     string "json:\"name\" graphql:\"name\""
	Services []*struct {
		Service  *ServiceDeploymentBaseFragment "json:\"service\" graphql:\"service\""
		Criteria *struct {
			Source  *ServiceDeploymentBaseFragment "json:\"source\" graphql:\"source\""
			Secrets []*string                      "json:\"secrets\" graphql:\"secrets\""
		} "json:\"criteria\" graphql:\"criteria\""
	} "json:\"services\" graphql:\"services\""
}
type PolicyBindingFragment struct {
	ID    *string        "json:\"id\" graphql:\"id\""
	Group *GroupFragment "json:\"group\" graphql:\"group\""
	User  *UserFragment  "json:\"user\" graphql:\"user\""
}
type ProviderCredentialFragment struct {
	ID        string "json:\"id\" graphql:\"id\""
	Name      string "json:\"name\" graphql:\"name\""
	Namespace string "json:\"namespace\" graphql:\"namespace\""
	Kind      string "json:\"kind\" graphql:\"kind\""
}
type RevisionFragment struct {
	ID  string  "json:\"id\" graphql:\"id\""
	Sha *string "json:\"sha\" graphql:\"sha\""
	Git *struct {
		Ref    string "json:\"ref\" graphql:\"ref\""
		Folder string "json:\"folder\" graphql:\"folder\""
	} "json:\"git\" graphql:\"git\""
}
type ServiceDeploymentBaseFragment struct {
	ID         string                 "json:\"id\" graphql:\"id\""
	Name       string                 "json:\"name\" graphql:\"name\""
	Namespace  string                 "json:\"namespace\" graphql:\"namespace\""
	Version    string                 "json:\"version\" graphql:\"version\""
	Kustomize  *KustomizeFragment     "json:\"kustomize\" graphql:\"kustomize\""
	Git        *GitRefFragment        "json:\"git\" graphql:\"git\""
	Helm       *HelmSpecFragment      "json:\"helm\" graphql:\"helm\""
	Repository *GitRepositoryFragment "json:\"repository\" graphql:\"repository\""
}
type ServiceDeploymentEdgeFragment struct {
	Node *ServiceDeploymentBaseFragment "json:\"node\" graphql:\"node\""
}
type ServiceDeploymentExtended struct {
	Cluster    *BaseClusterFragment   "json:\"cluster\" graphql:\"cluster\""
	Errors     []*ErrorFragment       "json:\"errors\" graphql:\"errors\""
	Revision   *RevisionFragment      "json:\"revision\" graphql:\"revision\""
	ID         string                 "json:\"id\" graphql:\"id\""
	Name       string                 "json:\"name\" graphql:\"name\""
	Namespace  string                 "json:\"namespace\" graphql:\"namespace\""
	Version    string                 "json:\"version\" graphql:\"version\""
	Kustomize  *KustomizeFragment     "json:\"kustomize\" graphql:\"kustomize\""
	Git        *GitRefFragment        "json:\"git\" graphql:\"git\""
	Helm       *HelmSpecFragment      "json:\"helm\" graphql:\"helm\""
	Repository *GitRepositoryFragment "json:\"repository\" graphql:\"repository\""
	Components []*struct {
		ID        string          "json:\"id\" graphql:\"id\""
		Name      string          "json:\"name\" graphql:\"name\""
		Group     *string         "json:\"group\" graphql:\"group\""
		Kind      string          "json:\"kind\" graphql:\"kind\""
		Namespace *string         "json:\"namespace\" graphql:\"namespace\""
		State     *ComponentState "json:\"state\" graphql:\"state\""
		Synced    bool            "json:\"synced\" graphql:\"synced\""
		Version   *string         "json:\"version\" graphql:\"version\""
	} "json:\"components\" graphql:\"components\""
	Protect       *bool   "json:\"protect\" graphql:\"protect\""
	DeletedAt     *string "json:\"deletedAt\" graphql:\"deletedAt\""
	Sha           *string "json:\"sha\" graphql:\"sha\""
	Tarball       *string "json:\"tarball\" graphql:\"tarball\""
	Configuration []*struct {
		Name  string "json:\"name\" graphql:\"name\""
		Value string "json:\"value\" graphql:\"value\""
	} "json:\"configuration\" graphql:\"configuration\""
}
type ServiceDeploymentFragment struct {
	ID         string                 "json:\"id\" graphql:\"id\""
	Name       string                 "json:\"name\" graphql:\"name\""
	Namespace  string                 "json:\"namespace\" graphql:\"namespace\""
	Version    string                 "json:\"version\" graphql:\"version\""
	Kustomize  *KustomizeFragment     "json:\"kustomize\" graphql:\"kustomize\""
	Git        *GitRefFragment        "json:\"git\" graphql:\"git\""
	Helm       *HelmSpecFragment      "json:\"helm\" graphql:\"helm\""
	Repository *GitRepositoryFragment "json:\"repository\" graphql:\"repository\""
	Components []*struct {
		ID        string          "json:\"id\" graphql:\"id\""
		Name      string          "json:\"name\" graphql:\"name\""
		Group     *string         "json:\"group\" graphql:\"group\""
		Kind      string          "json:\"kind\" graphql:\"kind\""
		Namespace *string         "json:\"namespace\" graphql:\"namespace\""
		State     *ComponentState "json:\"state\" graphql:\"state\""
		Synced    bool            "json:\"synced\" graphql:\"synced\""
		Version   *string         "json:\"version\" graphql:\"version\""
	} "json:\"components\" graphql:\"components\""
	Protect       *bool   "json:\"protect\" graphql:\"protect\""
	DeletedAt     *string "json:\"deletedAt\" graphql:\"deletedAt\""
	Sha           *string "json:\"sha\" graphql:\"sha\""
	Tarball       *string "json:\"tarball\" graphql:\"tarball\""
	Configuration []*struct {
		Name  string "json:\"name\" graphql:\"name\""
		Value string "json:\"value\" graphql:\"value\""
	} "json:\"configuration\" graphql:\"configuration\""
}
type UserFragment struct {
	Name  string "json:\"name\" graphql:\"name\""
	ID    string "json:\"id\" graphql:\"id\""
	Email string "json:\"email\" graphql:\"email\""
}
type AddGroupMember struct {
	CreateGroupMember *GroupMemberFragment "json:\"createGroupMember\" graphql:\"createGroupMember\""
}
type AddServiceError struct {
	UpdateServiceComponents *ServiceDeploymentFragment "json:\"updateServiceComponents\" graphql:\"updateServiceComponents\""
}
type CloneServiceDeployment struct {
	CloneService *ServiceDeploymentFragment "json:\"cloneService\" graphql:\"cloneService\""
}
type CloneServiceDeploymentWithHandle struct {
	CloneService *ServiceDeploymentFragment "json:\"cloneService\" graphql:\"cloneService\""
}
type CreateAccessToken struct {
	CreateAccessToken *AccessTokenFragment "json:\"createAccessToken\" graphql:\"createAccessToken\""
}
type CreateCluster struct {
	CreateCluster *struct {
		DeployToken    *string                     "json:\"deployToken\" graphql:\"deployToken\""
		ID             string                      "json:\"id\" graphql:\"id\""
		Name           string                      "json:\"name\" graphql:\"name\""
		Handle         *string                     "json:\"handle\" graphql:\"handle\""
		Self           *bool                       "json:\"self\" graphql:\"self\""
		Version        *string                     "json:\"version\" graphql:\"version\""
		InsertedAt     *string                     "json:\"insertedAt\" graphql:\"insertedAt\""
		PingedAt       *string                     "json:\"pingedAt\" graphql:\"pingedAt\""
		Protect        *bool                       "json:\"protect\" graphql:\"protect\""
		CurrentVersion *string                     "json:\"currentVersion\" graphql:\"currentVersion\""
		KasURL         *string                     "json:\"kasUrl\" graphql:\"kasUrl\""
		DeletedAt      *string                     "json:\"deletedAt\" graphql:\"deletedAt\""
		Tags           []*ClusterTags              "json:\"tags\" graphql:\"tags\""
		Credential     *ProviderCredentialFragment "json:\"credential\" graphql:\"credential\""
		Provider       *ClusterProviderFragment    "json:\"provider\" graphql:\"provider\""
		NodePools      []*NodePoolFragment         "json:\"nodePools\" graphql:\"nodePools\""
		Status         *ClusterStatusFragment      "json:\"status\" graphql:\"status\""
	} "json:\"createCluster\" graphql:\"createCluster\""
}
type CreateClusterProvider struct {
	CreateClusterProvider *ClusterProviderFragment "json:\"createClusterProvider\" graphql:\"createClusterProvider\""
}
type CreateGitRepository struct {
	CreateGitRepository *GitRepositoryFragment "json:\"createGitRepository\" graphql:\"createGitRepository\""
}
type CreateGlobalService struct {
	CreateGlobalService *GlobalServiceFragment "json:\"createGlobalService\" graphql:\"createGlobalService\""
}
type CreateGlobalServiceDeployment struct {
	CreateGlobalService *GlobalServiceFragment "json:\"createGlobalService\" graphql:\"createGlobalService\""
}
type CreateProviderCredential struct {
	CreateProviderCredential *ProviderCredentialFragment "json:\"createProviderCredential\" graphql:\"createProviderCredential\""
}
type CreateServiceDeployment struct {
	CreateServiceDeployment *ServiceDeploymentExtended "json:\"createServiceDeployment\" graphql:\"createServiceDeployment\""
}
type CreateServiceDeploymentWithHandle struct {
	CreateServiceDeployment *ServiceDeploymentExtended "json:\"createServiceDeployment\" graphql:\"createServiceDeployment\""
}
type DeleteAccessToken struct {
	DeleteAccessToken *AccessTokenFragment "json:\"deleteAccessToken\" graphql:\"deleteAccessToken\""
}
type DeleteCluster struct {
	DeleteCluster *ClusterFragment "json:\"deleteCluster\" graphql:\"deleteCluster\""
}
type DeleteClusterProvider struct {
	DeleteClusterProvider *ClusterProviderFragment "json:\"deleteClusterProvider\" graphql:\"deleteClusterProvider\""
}
type DeleteGitRepository struct {
	DeleteGitRepository *GitRepositoryFragment "json:\"deleteGitRepository\" graphql:\"deleteGitRepository\""
}
type DeleteGlobalService struct {
	DeleteGlobalService *GlobalServiceFragment "json:\"deleteGlobalService\" graphql:\"deleteGlobalService\""
}
type DeleteGlobalServiceDeployment struct {
	DeleteGlobalService *GlobalServiceFragment "json:\"deleteGlobalService\" graphql:\"deleteGlobalService\""
}
type DeleteGroupMember struct {
	DeleteGroupMember *GroupMemberFragment "json:\"deleteGroupMember\" graphql:\"deleteGroupMember\""
}
type DeletePipeline struct {
	DeletePipeline *PipelineFragment "json:\"deletePipeline\" graphql:\"deletePipeline\""
}
type DeleteProviderCredential struct {
	DeleteProviderCredential *ProviderCredentialFragment "json:\"deleteProviderCredential\" graphql:\"deleteProviderCredential\""
}
type DeleteServiceDeployment struct {
	DeleteServiceDeployment *ServiceDeploymentFragment "json:\"deleteServiceDeployment\" graphql:\"deleteServiceDeployment\""
}
type DetachCluster struct {
	DetachCluster *ClusterFragment "json:\"detachCluster\" graphql:\"detachCluster\""
}
type GetAccessToken struct {
	AccessToken *AccessTokenFragment "json:\"accessToken\" graphql:\"accessToken\""
}
type GetCluster struct {
	Cluster *ClusterFragment "json:\"cluster\" graphql:\"cluster\""
}
type GetClusterByHandle struct {
	Cluster *ClusterFragment "json:\"cluster\" graphql:\"cluster\""
}
type GetClusterGates struct {
	ClusterGates []*PipelineGateFragment "json:\"clusterGates\" graphql:\"clusterGates\""
}
type GetClusterProvider struct {
	ClusterProvider *ClusterProviderFragment "json:\"clusterProvider\" graphql:\"clusterProvider\""
}
type GetClusterProviderByCloud struct {
	ClusterProvider *ClusterProviderFragment "json:\"clusterProvider\" graphql:\"clusterProvider\""
}
type GetClusterWithToken struct {
	Cluster *struct {
		ID             string                      "json:\"id\" graphql:\"id\""
		Name           string                      "json:\"name\" graphql:\"name\""
		Handle         *string                     "json:\"handle\" graphql:\"handle\""
		Self           *bool                       "json:\"self\" graphql:\"self\""
		Version        *string                     "json:\"version\" graphql:\"version\""
		InsertedAt     *string                     "json:\"insertedAt\" graphql:\"insertedAt\""
		PingedAt       *string                     "json:\"pingedAt\" graphql:\"pingedAt\""
		Protect        *bool                       "json:\"protect\" graphql:\"protect\""
		CurrentVersion *string                     "json:\"currentVersion\" graphql:\"currentVersion\""
		KasURL         *string                     "json:\"kasUrl\" graphql:\"kasUrl\""
		DeletedAt      *string                     "json:\"deletedAt\" graphql:\"deletedAt\""
		Tags           []*ClusterTags              "json:\"tags\" graphql:\"tags\""
		Credential     *ProviderCredentialFragment "json:\"credential\" graphql:\"credential\""
		Provider       *ClusterProviderFragment    "json:\"provider\" graphql:\"provider\""
		NodePools      []*NodePoolFragment         "json:\"nodePools\" graphql:\"nodePools\""
		Status         *ClusterStatusFragment      "json:\"status\" graphql:\"status\""
		DeployToken    *string                     "json:\"deployToken\" graphql:\"deployToken\""
	} "json:\"cluster\" graphql:\"cluster\""
}
type GetGitRepository struct {
	GitRepository *GitRepositoryFragment "json:\"gitRepository\" graphql:\"gitRepository\""
}
type GetGlobalServiceDeployment struct {
	GlobalService *GlobalServiceFragment "json:\"globalService\" graphql:\"globalService\""
}
type GetGroup struct {
	Group *GroupFragment "json:\"group\" graphql:\"group\""
}
type GetPipeline struct {
	Pipeline *PipelineFragment "json:\"pipeline\" graphql:\"pipeline\""
}
type GetPipelines struct {
	Pipelines *struct {
		Edges []*PipelineEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"pipelines\" graphql:\"pipelines\""
}
type GetServiceDeployment struct {
	ServiceDeployment *ServiceDeploymentExtended "json:\"serviceDeployment\" graphql:\"serviceDeployment\""
}
type GetServiceDeploymentByHandle struct {
	ServiceDeployment *ServiceDeploymentExtended "json:\"serviceDeployment\" graphql:\"serviceDeployment\""
}
type GetUser struct {
	User *UserFragment "json:\"user\" graphql:\"user\""
}
type ListAccessTokens struct {
	AccessTokens *struct {
		Edges []*AccessTokenEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"accessTokens\" graphql:\"accessTokens\""
}
type ListClusterServices struct {
	ClusterServices []*ServiceDeploymentBaseFragment "json:\"clusterServices\" graphql:\"clusterServices\""
}
type ListClusters struct {
	Clusters *struct {
		Edges []*ClusterEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"clusters\" graphql:\"clusters\""
}
type ListDeploymentSettings struct {
	DeploymentSettings *DeploymentSettingsFragment "json:\"deploymentSettings\" graphql:\"deploymentSettings\""
}
type ListGitRepositories struct {
	GitRepositories *struct {
		Edges []*GitRepositoryEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"gitRepositories\" graphql:\"gitRepositories\""
}
type ListProviders struct {
	ClusterProviders *ClusterProviderConnectionFragment "json:\"clusterProviders\" graphql:\"clusterProviders\""
}
type ListServiceDeployment struct {
	ServiceDeployments *struct {
		Edges []*ServiceDeploymentEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"serviceDeployments\" graphql:\"serviceDeployments\""
}
type ListServiceDeploymentByHandle struct {
	ServiceDeployments *struct {
		Edges []*ServiceDeploymentEdgeFragment "json:\"edges\" graphql:\"edges\""
	} "json:\"serviceDeployments\" graphql:\"serviceDeployments\""
}
type ListServiceDeployments struct {
	ServiceDeployments *struct {
		Edges []*struct {
			Node *ServiceDeploymentFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"serviceDeployments\" graphql:\"serviceDeployments\""
}
type MyCluster struct {
	MyCluster *struct {
		ID   string "json:\"id\" graphql:\"id\""
		Name string "json:\"name\" graphql:\"name\""
	} "json:\"myCluster\" graphql:\"myCluster\""
}
type PingCluster struct {
	PingCluster *struct {
		ID   string "json:\"id\" graphql:\"id\""
		Name string "json:\"name\" graphql:\"name\""
	} "json:\"pingCluster\" graphql:\"pingCluster\""
}
type RegisterRuntimeServices struct {
	RegisterRuntimeServices *int64 "json:\"registerRuntimeServices\" graphql:\"registerRuntimeServices\""
}
type RollbackService struct {
	RollbackService *ServiceDeploymentFragment "json:\"rollbackService\" graphql:\"rollbackService\""
}
type SavePipeline struct {
	SavePipeline *PipelineFragment "json:\"savePipeline\" graphql:\"savePipeline\""
}
type TokenExchange struct {
	TokenExchange *struct {
		Name   string "json:\"name\" graphql:\"name\""
		ID     string "json:\"id\" graphql:\"id\""
		Email  string "json:\"email\" graphql:\"email\""
		Groups []*struct {
			ID   string "json:\"id\" graphql:\"id\""
			Name string "json:\"name\" graphql:\"name\""
		} "json:\"groups\" graphql:\"groups\""
		BoundRoles []*struct {
			ID   string "json:\"id\" graphql:\"id\""
			Name string "json:\"name\" graphql:\"name\""
		} "json:\"boundRoles\" graphql:\"boundRoles\""
	} "json:\"tokenExchange\" graphql:\"tokenExchange\""
}
type UpdateCluster struct {
	UpdateCluster *ClusterFragment "json:\"updateCluster\" graphql:\"updateCluster\""
}
type UpdateClusterProvider struct {
	UpdateClusterProvider *ClusterProviderFragment "json:\"updateClusterProvider\" graphql:\"updateClusterProvider\""
}
type UpdateDeploymentSettings struct {
	UpdateDeploymentSettings *DeploymentSettingsFragment "json:\"updateDeploymentSettings\" graphql:\"updateDeploymentSettings\""
}
type UpdateGitRepository struct {
	UpdateGitRepository *GitRepositoryFragment "json:\"updateGitRepository\" graphql:\"updateGitRepository\""
}
type UpdateGlobalService struct {
	UpdateGlobalService *GlobalServiceFragment "json:\"updateGlobalService\" graphql:\"updateGlobalService\""
}
type UpdateGlobalServiceDeployment struct {
	UpdateGlobalService *GlobalServiceFragment "json:\"updateGlobalService\" graphql:\"updateGlobalService\""
}
type UpdateRbac struct {
	UpdateRbac *bool "json:\"updateRbac\" graphql:\"updateRbac\""
}
type UpdateServiceDeployment struct {
	UpdateServiceDeployment *ServiceDeploymentExtended "json:\"updateServiceDeployment\" graphql:\"updateServiceDeployment\""
}
type UpdateServiceDeploymentWithHandle struct {
	UpdateServiceDeployment *ServiceDeploymentExtended "json:\"updateServiceDeployment\" graphql:\"updateServiceDeployment\""
}
type UpdateGate struct {
	UpdateGate *PipelineGateFragment "json:\"updateGate\" graphql:\"updateGate\""
}
type UpdateServiceComponents struct {
	UpdateServiceComponents *ServiceDeploymentFragment "json:\"updateServiceComponents\" graphql:\"updateServiceComponents\""
}

const AddGroupMemberDocument = `mutation AddGroupMember ($groupId: ID!, $userId: ID!) {
	createGroupMember(groupId: $groupId, userId: $userId) {
		... GroupMemberFragment
	}
}
fragment GroupMemberFragment on GroupMember {
	id
	user {
		id
	}
	group {
		id
	}
}
`

func (c *Client) AddGroupMember(ctx context.Context, groupID string, userID string, httpRequestOptions ...client.HTTPRequestOption) (*AddGroupMember, error) {
	vars := map[string]interface{}{
		"groupId": groupID,
		"userId":  userID,
	}

	var res AddGroupMember
	if err := c.Client.Post(ctx, "AddGroupMember", AddGroupMemberDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const AddServiceErrorDocument = `mutation AddServiceError ($id: ID!, $errors: [ServiceErrorAttributes]) {
	updateServiceComponents(id: $id, errors: $errors) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) AddServiceError(ctx context.Context, id string, errors []*ServiceErrorAttributes, httpRequestOptions ...client.HTTPRequestOption) (*AddServiceError, error) {
	vars := map[string]interface{}{
		"id":     id,
		"errors": errors,
	}

	var res AddServiceError
	if err := c.Client.Post(ctx, "AddServiceError", AddServiceErrorDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CloneServiceDeploymentDocument = `mutation CloneServiceDeployment ($clusterId: ID!, $id: ID!, $attributes: ServiceCloneAttributes!) {
	cloneService(clusterId: $clusterId, serviceId: $id, attributes: $attributes) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CloneServiceDeployment(ctx context.Context, clusterID string, id string, attributes ServiceCloneAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CloneServiceDeployment, error) {
	vars := map[string]interface{}{
		"clusterId":  clusterID,
		"id":         id,
		"attributes": attributes,
	}

	var res CloneServiceDeployment
	if err := c.Client.Post(ctx, "CloneServiceDeployment", CloneServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CloneServiceDeploymentWithHandleDocument = `mutation CloneServiceDeploymentWithHandle ($clusterId: ID!, $cluster: String!, $name: String!, $attributes: ServiceCloneAttributes!) {
	cloneService(clusterId: $clusterId, cluster: $cluster, name: $name, attributes: $attributes) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CloneServiceDeploymentWithHandle(ctx context.Context, clusterID string, cluster string, name string, attributes ServiceCloneAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CloneServiceDeploymentWithHandle, error) {
	vars := map[string]interface{}{
		"clusterId":  clusterID,
		"cluster":    cluster,
		"name":       name,
		"attributes": attributes,
	}

	var res CloneServiceDeploymentWithHandle
	if err := c.Client.Post(ctx, "CloneServiceDeploymentWithHandle", CloneServiceDeploymentWithHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateAccessTokenDocument = `mutation CreateAccessToken {
	createAccessToken {
		... AccessTokenFragment
	}
}
fragment AccessTokenFragment on AccessToken {
	id
	token
}
`

func (c *Client) CreateAccessToken(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*CreateAccessToken, error) {
	vars := map[string]interface{}{}

	var res CreateAccessToken
	if err := c.Client.Post(ctx, "CreateAccessToken", CreateAccessTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateClusterDocument = `mutation CreateCluster ($attributes: ClusterAttributes!) {
	createCluster(attributes: $attributes) {
		deployToken
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CreateCluster(ctx context.Context, attributes ClusterAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateCluster, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res CreateCluster
	if err := c.Client.Post(ctx, "CreateCluster", CreateClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateClusterProviderDocument = `mutation CreateClusterProvider ($attributes: ClusterProviderAttributes!) {
	createClusterProvider(attributes: $attributes) {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CreateClusterProvider(ctx context.Context, attributes ClusterProviderAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateClusterProvider, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res CreateClusterProvider
	if err := c.Client.Post(ctx, "CreateClusterProvider", CreateClusterProviderDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateGitRepositoryDocument = `mutation CreateGitRepository ($attributes: GitAttributes!) {
	createGitRepository(attributes: $attributes) {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
`

func (c *Client) CreateGitRepository(ctx context.Context, attributes GitAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateGitRepository, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res CreateGitRepository
	if err := c.Client.Post(ctx, "CreateGitRepository", CreateGitRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateGlobalServiceDocument = `mutation CreateGlobalService ($attributes: GlobalServiceAttributes!) {
	createGlobalService(attributes: $attributes) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) CreateGlobalService(ctx context.Context, attributes GlobalServiceAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateGlobalService, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res CreateGlobalService
	if err := c.Client.Post(ctx, "CreateGlobalService", CreateGlobalServiceDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateGlobalServiceDeploymentDocument = `mutation CreateGlobalServiceDeployment ($serviceId: ID!, $attributes: GlobalServiceAttributes!) {
	createGlobalService(serviceId: $serviceId, attributes: $attributes) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) CreateGlobalServiceDeployment(ctx context.Context, serviceID string, attributes GlobalServiceAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateGlobalServiceDeployment, error) {
	vars := map[string]interface{}{
		"serviceId":  serviceID,
		"attributes": attributes,
	}

	var res CreateGlobalServiceDeployment
	if err := c.Client.Post(ctx, "CreateGlobalServiceDeployment", CreateGlobalServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateProviderCredentialDocument = `mutation CreateProviderCredential ($attributes: ProviderCredentialAttributes!, $name: String!) {
	createProviderCredential(attributes: $attributes, name: $name) {
		... ProviderCredentialFragment
	}
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
`

func (c *Client) CreateProviderCredential(ctx context.Context, attributes ProviderCredentialAttributes, name string, httpRequestOptions ...client.HTTPRequestOption) (*CreateProviderCredential, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
		"name":       name,
	}

	var res CreateProviderCredential
	if err := c.Client.Post(ctx, "CreateProviderCredential", CreateProviderCredentialDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateServiceDeploymentDocument = `mutation CreateServiceDeployment ($clusterId: ID!, $attributes: ServiceDeploymentAttributes!) {
	createServiceDeployment(clusterId: $clusterId, attributes: $attributes) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CreateServiceDeployment(ctx context.Context, clusterID string, attributes ServiceDeploymentAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateServiceDeployment, error) {
	vars := map[string]interface{}{
		"clusterId":  clusterID,
		"attributes": attributes,
	}

	var res CreateServiceDeployment
	if err := c.Client.Post(ctx, "CreateServiceDeployment", CreateServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateServiceDeploymentWithHandleDocument = `mutation CreateServiceDeploymentWithHandle ($cluster: String!, $attributes: ServiceDeploymentAttributes!) {
	createServiceDeployment(cluster: $cluster, attributes: $attributes) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) CreateServiceDeploymentWithHandle(ctx context.Context, cluster string, attributes ServiceDeploymentAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateServiceDeploymentWithHandle, error) {
	vars := map[string]interface{}{
		"cluster":    cluster,
		"attributes": attributes,
	}

	var res CreateServiceDeploymentWithHandle
	if err := c.Client.Post(ctx, "CreateServiceDeploymentWithHandle", CreateServiceDeploymentWithHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteAccessTokenDocument = `mutation DeleteAccessToken ($token: String!) {
	deleteAccessToken(token: $token) {
		... AccessTokenFragment
	}
}
fragment AccessTokenFragment on AccessToken {
	id
	token
}
`

func (c *Client) DeleteAccessToken(ctx context.Context, token string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteAccessToken, error) {
	vars := map[string]interface{}{
		"token": token,
	}

	var res DeleteAccessToken
	if err := c.Client.Post(ctx, "DeleteAccessToken", DeleteAccessTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteClusterDocument = `mutation DeleteCluster ($id: ID!) {
	deleteCluster(id: $id) {
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) DeleteCluster(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteCluster, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteCluster
	if err := c.Client.Post(ctx, "DeleteCluster", DeleteClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteClusterProviderDocument = `mutation DeleteClusterProvider ($id: ID!) {
	deleteClusterProvider(id: $id) {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) DeleteClusterProvider(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteClusterProvider, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteClusterProvider
	if err := c.Client.Post(ctx, "DeleteClusterProvider", DeleteClusterProviderDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteGitRepositoryDocument = `mutation DeleteGitRepository ($id: ID!) {
	deleteGitRepository(id: $id) {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
`

func (c *Client) DeleteGitRepository(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteGitRepository, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteGitRepository
	if err := c.Client.Post(ctx, "DeleteGitRepository", DeleteGitRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteGlobalServiceDocument = `mutation DeleteGlobalService ($id: ID!) {
	deleteGlobalService(id: $id) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) DeleteGlobalService(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteGlobalService, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteGlobalService
	if err := c.Client.Post(ctx, "DeleteGlobalService", DeleteGlobalServiceDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteGlobalServiceDeploymentDocument = `mutation DeleteGlobalServiceDeployment ($id: ID!) {
	deleteGlobalService(id: $id) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) DeleteGlobalServiceDeployment(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteGlobalServiceDeployment, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteGlobalServiceDeployment
	if err := c.Client.Post(ctx, "DeleteGlobalServiceDeployment", DeleteGlobalServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteGroupMemberDocument = `mutation DeleteGroupMember ($userId: ID!, $groupId: ID!) {
	deleteGroupMember(userId: $userId, groupId: $groupId) {
		... GroupMemberFragment
	}
}
fragment GroupMemberFragment on GroupMember {
	id
	user {
		id
	}
	group {
		id
	}
}
`

func (c *Client) DeleteGroupMember(ctx context.Context, userID string, groupID string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteGroupMember, error) {
	vars := map[string]interface{}{
		"userId":  userID,
		"groupId": groupID,
	}

	var res DeleteGroupMember
	if err := c.Client.Post(ctx, "DeleteGroupMember", DeleteGroupMemberDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeletePipelineDocument = `mutation DeletePipeline ($id: ID!) {
	deletePipeline(id: $id) {
		... PipelineFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment PipelineFragment on Pipeline {
	id
	name
	stages {
		... PipelineStageFragment
	}
	edges {
		... PipelineStageEdgeFragment
	}
}
fragment PipelineStageEdgeFragment on PipelineStageEdge {
	id
	from {
		... PipelineStageFragment
	}
	to {
		... PipelineStageFragment
	}
}
fragment PipelineStageFragment on PipelineStage {
	id
	name
	services {
		service {
			... ServiceDeploymentBaseFragment
		}
		criteria {
			source {
				... ServiceDeploymentBaseFragment
			}
			secrets
		}
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
`

func (c *Client) DeletePipeline(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeletePipeline, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeletePipeline
	if err := c.Client.Post(ctx, "DeletePipeline", DeletePipelineDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteProviderCredentialDocument = `mutation DeleteProviderCredential ($id: ID!) {
	deleteProviderCredential(id: $id) {
		... ProviderCredentialFragment
	}
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
`

func (c *Client) DeleteProviderCredential(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteProviderCredential, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteProviderCredential
	if err := c.Client.Post(ctx, "DeleteProviderCredential", DeleteProviderCredentialDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteServiceDeploymentDocument = `mutation DeleteServiceDeployment ($id: ID!) {
	deleteServiceDeployment(id: $id) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) DeleteServiceDeployment(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteServiceDeployment, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteServiceDeployment
	if err := c.Client.Post(ctx, "DeleteServiceDeployment", DeleteServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DetachClusterDocument = `mutation DetachCluster ($id: ID!) {
	detachCluster(id: $id) {
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) DetachCluster(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DetachCluster, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DetachCluster
	if err := c.Client.Post(ctx, "DetachCluster", DetachClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetAccessTokenDocument = `query GetAccessToken ($id: ID!) {
	accessToken(id: $id) {
		... AccessTokenFragment
	}
}
fragment AccessTokenFragment on AccessToken {
	id
	token
}
`

func (c *Client) GetAccessToken(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetAccessToken, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetAccessToken
	if err := c.Client.Post(ctx, "GetAccessToken", GetAccessTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterDocument = `query GetCluster ($id: ID) {
	cluster(id: $id) {
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetCluster(ctx context.Context, id *string, httpRequestOptions ...client.HTTPRequestOption) (*GetCluster, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetCluster
	if err := c.Client.Post(ctx, "GetCluster", GetClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterByHandleDocument = `query GetClusterByHandle ($handle: String) {
	cluster(handle: $handle) {
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetClusterByHandle(ctx context.Context, handle *string, httpRequestOptions ...client.HTTPRequestOption) (*GetClusterByHandle, error) {
	vars := map[string]interface{}{
		"handle": handle,
	}

	var res GetClusterByHandle
	if err := c.Client.Post(ctx, "GetClusterByHandle", GetClusterByHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterGatesDocument = `query GetClusterGates {
	clusterGates {
		... PipelineGateFragment
	}
}
fragment ContainerSpecFragment on ContainerSpec {
	image
	args
	env {
		name
		value
	}
	envFrom {
		configMap
		secret
	}
}
fragment GateSpecFragment on GateSpec {
	job {
		... JobSpecFragment
	}
}
fragment JobSpecFragment on JobGateSpec {
	namespace
	raw
	containers {
		... ContainerSpecFragment
	}
	labels
	annotations
	serviceAccount
}
fragment PipelineGateFragment on PipelineGate {
	id
	name
	type
	state
	updatedAt
	spec {
		... GateSpecFragment
	}
}
`

func (c *Client) GetClusterGates(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*GetClusterGates, error) {
	vars := map[string]interface{}{}

	var res GetClusterGates
	if err := c.Client.Post(ctx, "GetClusterGates", GetClusterGatesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterProviderDocument = `query GetClusterProvider ($id: ID!) {
	clusterProvider(id: $id) {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetClusterProvider(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetClusterProvider, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetClusterProvider
	if err := c.Client.Post(ctx, "GetClusterProvider", GetClusterProviderDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterProviderByCloudDocument = `query GetClusterProviderByCloud ($cloud: String!) {
	clusterProvider(cloud: $cloud) {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetClusterProviderByCloud(ctx context.Context, cloud string, httpRequestOptions ...client.HTTPRequestOption) (*GetClusterProviderByCloud, error) {
	vars := map[string]interface{}{
		"cloud": cloud,
	}

	var res GetClusterProviderByCloud
	if err := c.Client.Post(ctx, "GetClusterProviderByCloud", GetClusterProviderByCloudDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetClusterWithTokenDocument = `query GetClusterWithToken ($id: ID, $handle: String) {
	cluster(id: $id, handle: $handle) {
		... ClusterFragment
		deployToken
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetClusterWithToken(ctx context.Context, id *string, handle *string, httpRequestOptions ...client.HTTPRequestOption) (*GetClusterWithToken, error) {
	vars := map[string]interface{}{
		"id":     id,
		"handle": handle,
	}

	var res GetClusterWithToken
	if err := c.Client.Post(ctx, "GetClusterWithToken", GetClusterWithTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetGitRepositoryDocument = `query GetGitRepository ($id: ID, $url: String) {
	gitRepository(id: $id, url: $url) {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
`

func (c *Client) GetGitRepository(ctx context.Context, id *string, url *string, httpRequestOptions ...client.HTTPRequestOption) (*GetGitRepository, error) {
	vars := map[string]interface{}{
		"id":  id,
		"url": url,
	}

	var res GetGitRepository
	if err := c.Client.Post(ctx, "GetGitRepository", GetGitRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetGlobalServiceDeploymentDocument = `query GetGlobalServiceDeployment ($id: ID!) {
	globalService(id: $id) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) GetGlobalServiceDeployment(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetGlobalServiceDeployment, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetGlobalServiceDeployment
	if err := c.Client.Post(ctx, "GetGlobalServiceDeployment", GetGlobalServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetGroupDocument = `query GetGroup ($name: String!) {
	group(name: $name) {
		... GroupFragment
	}
}
fragment GroupFragment on Group {
	id
	name
	description
}
`

func (c *Client) GetGroup(ctx context.Context, name string, httpRequestOptions ...client.HTTPRequestOption) (*GetGroup, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res GetGroup
	if err := c.Client.Post(ctx, "GetGroup", GetGroupDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetPipelineDocument = `query GetPipeline ($id: ID!) {
	pipeline(id: $id) {
		... PipelineFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment PipelineFragment on Pipeline {
	id
	name
	stages {
		... PipelineStageFragment
	}
	edges {
		... PipelineStageEdgeFragment
	}
}
fragment PipelineStageEdgeFragment on PipelineStageEdge {
	id
	from {
		... PipelineStageFragment
	}
	to {
		... PipelineStageFragment
	}
}
fragment PipelineStageFragment on PipelineStage {
	id
	name
	services {
		service {
			... ServiceDeploymentBaseFragment
		}
		criteria {
			source {
				... ServiceDeploymentBaseFragment
			}
			secrets
		}
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
`

func (c *Client) GetPipeline(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetPipeline, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetPipeline
	if err := c.Client.Post(ctx, "GetPipeline", GetPipelineDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetPipelinesDocument = `query GetPipelines ($after: String) {
	pipelines(first: 100, after: $after) {
		edges {
			... PipelineEdgeFragment
		}
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment PipelineEdgeFragment on PipelineEdge {
	node {
		... PipelineFragment
	}
}
fragment PipelineFragment on Pipeline {
	id
	name
	stages {
		... PipelineStageFragment
	}
	edges {
		... PipelineStageEdgeFragment
	}
}
fragment PipelineStageEdgeFragment on PipelineStageEdge {
	id
	from {
		... PipelineStageFragment
	}
	to {
		... PipelineStageFragment
	}
}
fragment PipelineStageFragment on PipelineStage {
	id
	name
	services {
		service {
			... ServiceDeploymentBaseFragment
		}
		criteria {
			source {
				... ServiceDeploymentBaseFragment
			}
			secrets
		}
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
`

func (c *Client) GetPipelines(ctx context.Context, after *string, httpRequestOptions ...client.HTTPRequestOption) (*GetPipelines, error) {
	vars := map[string]interface{}{
		"after": after,
	}

	var res GetPipelines
	if err := c.Client.Post(ctx, "GetPipelines", GetPipelinesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetServiceDeploymentDocument = `query GetServiceDeployment ($id: ID!) {
	serviceDeployment(id: $id) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetServiceDeployment(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetServiceDeployment, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetServiceDeployment
	if err := c.Client.Post(ctx, "GetServiceDeployment", GetServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetServiceDeploymentByHandleDocument = `query GetServiceDeploymentByHandle ($cluster: String!, $name: String!) {
	serviceDeployment(cluster: $cluster, name: $name) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) GetServiceDeploymentByHandle(ctx context.Context, cluster string, name string, httpRequestOptions ...client.HTTPRequestOption) (*GetServiceDeploymentByHandle, error) {
	vars := map[string]interface{}{
		"cluster": cluster,
		"name":    name,
	}

	var res GetServiceDeploymentByHandle
	if err := c.Client.Post(ctx, "GetServiceDeploymentByHandle", GetServiceDeploymentByHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetUserDocument = `query GetUser ($email: String!) {
	user(email: $email) {
		... UserFragment
	}
}
fragment UserFragment on User {
	name
	id
	email
}
`

func (c *Client) GetUser(ctx context.Context, email string, httpRequestOptions ...client.HTTPRequestOption) (*GetUser, error) {
	vars := map[string]interface{}{
		"email": email,
	}

	var res GetUser
	if err := c.Client.Post(ctx, "GetUser", GetUserDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListAccessTokensDocument = `query ListAccessTokens ($cursor: String, $before: String, $last: Int) {
	accessTokens(after: $cursor, first: 100, before: $before, last: $last) {
		edges {
			... AccessTokenEdgeFragment
		}
	}
}
fragment AccessTokenEdgeFragment on AccessTokenEdge {
	node {
		... AccessTokenFragment
	}
}
fragment AccessTokenFragment on AccessToken {
	id
	token
}
`

func (c *Client) ListAccessTokens(ctx context.Context, cursor *string, before *string, last *int64, httpRequestOptions ...client.HTTPRequestOption) (*ListAccessTokens, error) {
	vars := map[string]interface{}{
		"cursor": cursor,
		"before": before,
		"last":   last,
	}

	var res ListAccessTokens
	if err := c.Client.Post(ctx, "ListAccessTokens", ListAccessTokensDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListClusterServicesDocument = `query ListClusterServices {
	clusterServices {
		... ServiceDeploymentBaseFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
`

func (c *Client) ListClusterServices(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*ListClusterServices, error) {
	vars := map[string]interface{}{}

	var res ListClusterServices
	if err := c.Client.Post(ctx, "ListClusterServices", ListClusterServicesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListClustersDocument = `query ListClusters ($cursor: String, $before: String, $last: Int) {
	clusters(after: $cursor, first: 100, before: $before, last: $last) {
		edges {
			... ClusterEdgeFragment
		}
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterEdgeFragment on ClusterEdge {
	node {
		... ClusterFragment
	}
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) ListClusters(ctx context.Context, cursor *string, before *string, last *int64, httpRequestOptions ...client.HTTPRequestOption) (*ListClusters, error) {
	vars := map[string]interface{}{
		"cursor": cursor,
		"before": before,
		"last":   last,
	}

	var res ListClusters
	if err := c.Client.Post(ctx, "ListClusters", ListClustersDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListDeploymentSettingsDocument = `query ListDeploymentSettings {
	deploymentSettings {
		... DeploymentSettingsFragment
	}
}
fragment DeploymentSettingsFragment on DeploymentSettings {
	id
	name
	writeBindings {
		... PolicyBindingFragment
	}
	readBindings {
		... PolicyBindingFragment
	}
	createBindings {
		... PolicyBindingFragment
	}
	artifactRepository {
		... GitRepositoryFragment
	}
	deployerRepository {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment GroupFragment on Group {
	id
	name
	description
}
fragment PolicyBindingFragment on PolicyBinding {
	id
	group {
		... GroupFragment
	}
	user {
		... UserFragment
	}
}
fragment UserFragment on User {
	name
	id
	email
}
`

func (c *Client) ListDeploymentSettings(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*ListDeploymentSettings, error) {
	vars := map[string]interface{}{}

	var res ListDeploymentSettings
	if err := c.Client.Post(ctx, "ListDeploymentSettings", ListDeploymentSettingsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListGitRepositoriesDocument = `query ListGitRepositories ($cursor: String, $before: String, $last: Int) {
	gitRepositories(after: $cursor, first: 100, before: $before, last: $last) {
		edges {
			... GitRepositoryEdgeFragment
		}
	}
}
fragment GitRepositoryEdgeFragment on GitRepositoryEdge {
	node {
		... GitRepositoryFragment
	}
	cursor
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
`

func (c *Client) ListGitRepositories(ctx context.Context, cursor *string, before *string, last *int64, httpRequestOptions ...client.HTTPRequestOption) (*ListGitRepositories, error) {
	vars := map[string]interface{}{
		"cursor": cursor,
		"before": before,
		"last":   last,
	}

	var res ListGitRepositories
	if err := c.Client.Post(ctx, "ListGitRepositories", ListGitRepositoriesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListProvidersDocument = `query ListProviders {
	clusterProviders(first: 100) {
		... ClusterProviderConnectionFragment
	}
}
fragment ClusterProviderConnectionFragment on ClusterProviderConnection {
	edges {
		... ClusterProviderEdgeFragment
	}
}
fragment ClusterProviderEdgeFragment on ClusterProviderEdge {
	node {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) ListProviders(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*ListProviders, error) {
	vars := map[string]interface{}{}

	var res ListProviders
	if err := c.Client.Post(ctx, "ListProviders", ListProvidersDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListServiceDeploymentDocument = `query ListServiceDeployment ($after: String, $before: String, $last: Int, $clusterId: ID) {
	serviceDeployments(after: $after, first: 100, before: $before, last: $last, clusterId: $clusterId) {
		edges {
			... ServiceDeploymentEdgeFragment
		}
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentEdgeFragment on ServiceDeploymentEdge {
	node {
		... ServiceDeploymentBaseFragment
	}
}
`

func (c *Client) ListServiceDeployment(ctx context.Context, after *string, before *string, last *int64, clusterID *string, httpRequestOptions ...client.HTTPRequestOption) (*ListServiceDeployment, error) {
	vars := map[string]interface{}{
		"after":     after,
		"before":    before,
		"last":      last,
		"clusterId": clusterID,
	}

	var res ListServiceDeployment
	if err := c.Client.Post(ctx, "ListServiceDeployment", ListServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListServiceDeploymentByHandleDocument = `query ListServiceDeploymentByHandle ($after: String, $before: String, $last: Int, $cluster: String) {
	serviceDeployments(after: $after, first: 100, before: $before, last: $last, cluster: $cluster) {
		edges {
			... ServiceDeploymentEdgeFragment
		}
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentEdgeFragment on ServiceDeploymentEdge {
	node {
		... ServiceDeploymentBaseFragment
	}
}
`

func (c *Client) ListServiceDeploymentByHandle(ctx context.Context, after *string, before *string, last *int64, cluster *string, httpRequestOptions ...client.HTTPRequestOption) (*ListServiceDeploymentByHandle, error) {
	vars := map[string]interface{}{
		"after":   after,
		"before":  before,
		"last":    last,
		"cluster": cluster,
	}

	var res ListServiceDeploymentByHandle
	if err := c.Client.Post(ctx, "ListServiceDeploymentByHandle", ListServiceDeploymentByHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListServiceDeploymentsDocument = `query ListServiceDeployments ($cursor: String, $before: String, $last: Int) {
	serviceDeployments(after: $cursor, first: 100, before: $before, last: $last) {
		edges {
			node {
				... ServiceDeploymentFragment
			}
		}
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) ListServiceDeployments(ctx context.Context, cursor *string, before *string, last *int64, httpRequestOptions ...client.HTTPRequestOption) (*ListServiceDeployments, error) {
	vars := map[string]interface{}{
		"cursor": cursor,
		"before": before,
		"last":   last,
	}

	var res ListServiceDeployments
	if err := c.Client.Post(ctx, "ListServiceDeployments", ListServiceDeploymentsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const MyClusterDocument = `query MyCluster {
	myCluster {
		... {
			id
			name
		}
	}
}
`

func (c *Client) MyCluster(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*MyCluster, error) {
	vars := map[string]interface{}{}

	var res MyCluster
	if err := c.Client.Post(ctx, "MyCluster", MyClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const PingClusterDocument = `mutation PingCluster ($attributes: ClusterPing!) {
	pingCluster(attributes: $attributes) {
		id
		name
	}
}
`

func (c *Client) PingCluster(ctx context.Context, attributes ClusterPing, httpRequestOptions ...client.HTTPRequestOption) (*PingCluster, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res PingCluster
	if err := c.Client.Post(ctx, "PingCluster", PingClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const RegisterRuntimeServicesDocument = `mutation RegisterRuntimeServices ($services: [RuntimeServiceAttributes], $serviceId: ID) {
	registerRuntimeServices(services: $services, serviceId: $serviceId)
}
`

func (c *Client) RegisterRuntimeServices(ctx context.Context, services []*RuntimeServiceAttributes, serviceID *string, httpRequestOptions ...client.HTTPRequestOption) (*RegisterRuntimeServices, error) {
	vars := map[string]interface{}{
		"services":  services,
		"serviceId": serviceID,
	}

	var res RegisterRuntimeServices
	if err := c.Client.Post(ctx, "RegisterRuntimeServices", RegisterRuntimeServicesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const RollbackServiceDocument = `mutation RollbackService ($id: ID!, $revisionId: ID!) {
	rollbackService(id: $id, revisionId: $revisionId) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) RollbackService(ctx context.Context, id string, revisionID string, httpRequestOptions ...client.HTTPRequestOption) (*RollbackService, error) {
	vars := map[string]interface{}{
		"id":         id,
		"revisionId": revisionID,
	}

	var res RollbackService
	if err := c.Client.Post(ctx, "RollbackService", RollbackServiceDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const SavePipelineDocument = `mutation SavePipeline ($name: String!, $attributes: PipelineAttributes!) {
	savePipeline(name: $name, attributes: $attributes) {
		... PipelineFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment PipelineFragment on Pipeline {
	id
	name
	stages {
		... PipelineStageFragment
	}
	edges {
		... PipelineStageEdgeFragment
	}
}
fragment PipelineStageEdgeFragment on PipelineStageEdge {
	id
	from {
		... PipelineStageFragment
	}
	to {
		... PipelineStageFragment
	}
}
fragment PipelineStageFragment on PipelineStage {
	id
	name
	services {
		service {
			... ServiceDeploymentBaseFragment
		}
		criteria {
			source {
				... ServiceDeploymentBaseFragment
			}
			secrets
		}
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
`

func (c *Client) SavePipeline(ctx context.Context, name string, attributes PipelineAttributes, httpRequestOptions ...client.HTTPRequestOption) (*SavePipeline, error) {
	vars := map[string]interface{}{
		"name":       name,
		"attributes": attributes,
	}

	var res SavePipeline
	if err := c.Client.Post(ctx, "SavePipeline", SavePipelineDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const TokenExchangeDocument = `query TokenExchange ($token: String!) {
	tokenExchange(token: $token) {
		... UserFragment
		groups {
			id
			name
		}
		boundRoles {
			id
			name
		}
	}
}
fragment UserFragment on User {
	name
	id
	email
}
`

func (c *Client) TokenExchange(ctx context.Context, token string, httpRequestOptions ...client.HTTPRequestOption) (*TokenExchange, error) {
	vars := map[string]interface{}{
		"token": token,
	}

	var res TokenExchange
	if err := c.Client.Post(ctx, "TokenExchange", TokenExchangeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateClusterDocument = `mutation UpdateCluster ($id: ID!, $attributes: ClusterUpdateAttributes!) {
	updateCluster(id: $id, attributes: $attributes) {
		... ClusterFragment
	}
}
fragment ClusterConditionFragment on ClusterCondition {
	lastTransitionTime
	status
	type
	message
	reason
	severity
}
fragment ClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	insertedAt
	pingedAt
	protect
	currentVersion
	kasUrl
	deletedAt
	tags {
		... ClusterTags
	}
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... ClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
	status {
		... ClusterStatusFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment ClusterStatusFragment on ClusterStatus {
	conditions {
		... ClusterConditionFragment
	}
	controlPlaneReady
	failureMessage
	failureReason
	phase
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) UpdateCluster(ctx context.Context, id string, attributes ClusterUpdateAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateCluster, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateCluster
	if err := c.Client.Post(ctx, "UpdateCluster", UpdateClusterDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateClusterProviderDocument = `mutation UpdateClusterProvider ($id: ID!, $attributes: ClusterProviderUpdateAttributes!) {
	updateClusterProvider(id: $id, attributes: $attributes) {
		... ClusterProviderFragment
	}
}
fragment ClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	deletedAt
	repository {
		... GitRepositoryFragment
	}
	service {
		... ServiceDeploymentFragment
	}
	credentials {
		... ProviderCredentialFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) UpdateClusterProvider(ctx context.Context, id string, attributes ClusterProviderUpdateAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateClusterProvider, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateClusterProvider
	if err := c.Client.Post(ctx, "UpdateClusterProvider", UpdateClusterProviderDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateDeploymentSettingsDocument = `mutation UpdateDeploymentSettings ($attributes: DeploymentSettingsAttributes!) {
	updateDeploymentSettings(attributes: $attributes) {
		... DeploymentSettingsFragment
	}
}
fragment DeploymentSettingsFragment on DeploymentSettings {
	id
	name
	writeBindings {
		... PolicyBindingFragment
	}
	readBindings {
		... PolicyBindingFragment
	}
	createBindings {
		... PolicyBindingFragment
	}
	artifactRepository {
		... GitRepositoryFragment
	}
	deployerRepository {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment GroupFragment on Group {
	id
	name
	description
}
fragment PolicyBindingFragment on PolicyBinding {
	id
	group {
		... GroupFragment
	}
	user {
		... UserFragment
	}
}
fragment UserFragment on User {
	name
	id
	email
}
`

func (c *Client) UpdateDeploymentSettings(ctx context.Context, attributes DeploymentSettingsAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateDeploymentSettings, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res UpdateDeploymentSettings
	if err := c.Client.Post(ctx, "UpdateDeploymentSettings", UpdateDeploymentSettingsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateGitRepositoryDocument = `mutation UpdateGitRepository ($id: ID!, $attributes: GitAttributes!) {
	updateGitRepository(id: $id, attributes: $attributes) {
		... GitRepositoryFragment
	}
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
`

func (c *Client) UpdateGitRepository(ctx context.Context, id string, attributes GitAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateGitRepository, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateGitRepository
	if err := c.Client.Post(ctx, "UpdateGitRepository", UpdateGitRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateGlobalServiceDocument = `mutation UpdateGlobalService ($id: ID!, $attributes: GlobalServiceAttributes!) {
	updateGlobalService(id: $id, attributes: $attributes) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) UpdateGlobalService(ctx context.Context, id string, attributes GlobalServiceAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateGlobalService, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateGlobalService
	if err := c.Client.Post(ctx, "UpdateGlobalService", UpdateGlobalServiceDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateGlobalServiceDeploymentDocument = `mutation UpdateGlobalServiceDeployment ($id: ID!, $attributes: GlobalServiceAttributes!) {
	updateGlobalService(id: $id, attributes: $attributes) {
		... GlobalServiceFragment
	}
}
fragment ClusterTags on Tag {
	name
	value
}
fragment GlobalServiceFragment on GlobalService {
	id
	name
	distro
	provider {
		id
	}
	service {
		id
	}
	tags {
		... ClusterTags
	}
}
`

func (c *Client) UpdateGlobalServiceDeployment(ctx context.Context, id string, attributes GlobalServiceAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateGlobalServiceDeployment, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateGlobalServiceDeployment
	if err := c.Client.Post(ctx, "UpdateGlobalServiceDeployment", UpdateGlobalServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateRbacDocument = `mutation UpdateRbac ($rbac: RbacAttributes!, $serviceId: ID, $clusterId: ID, $providerId: ID) {
	updateRbac(rbac: $rbac, serviceId: $serviceId, clusterId: $clusterId, providerId: $providerId)
}
`

func (c *Client) UpdateRbac(ctx context.Context, rbac RbacAttributes, serviceID *string, clusterID *string, providerID *string, httpRequestOptions ...client.HTTPRequestOption) (*UpdateRbac, error) {
	vars := map[string]interface{}{
		"rbac":       rbac,
		"serviceId":  serviceID,
		"clusterId":  clusterID,
		"providerId": providerID,
	}

	var res UpdateRbac
	if err := c.Client.Post(ctx, "UpdateRbac", UpdateRbacDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateServiceDeploymentDocument = `mutation UpdateServiceDeployment ($id: ID!, $attributes: ServiceUpdateAttributes!) {
	updateServiceDeployment(id: $id, attributes: $attributes) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) UpdateServiceDeployment(ctx context.Context, id string, attributes ServiceUpdateAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateServiceDeployment, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateServiceDeployment
	if err := c.Client.Post(ctx, "UpdateServiceDeployment", UpdateServiceDeploymentDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateServiceDeploymentWithHandleDocument = `mutation UpdateServiceDeploymentWithHandle ($cluster: String!, $name: String!, $attributes: ServiceUpdateAttributes!) {
	updateServiceDeployment(cluster: $cluster, name: $name, attributes: $attributes) {
		... ServiceDeploymentExtended
	}
}
fragment BaseClusterFragment on Cluster {
	id
	name
	handle
	self
	version
	pingedAt
	currentVersion
	kasUrl
	credential {
		... ProviderCredentialFragment
	}
	provider {
		... BaseClusterProviderFragment
	}
	nodePools {
		... NodePoolFragment
	}
}
fragment BaseClusterProviderFragment on ClusterProvider {
	id
	name
	namespace
	cloud
	editable
	repository {
		... GitRepositoryFragment
	}
}
fragment ErrorFragment on ServiceError {
	source
	message
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment NodePoolFragment on NodePool {
	id
	name
	minSize
	maxSize
	instanceType
	labels
	taints {
		... NodePoolTaintFragment
	}
}
fragment NodePoolTaintFragment on Taint {
	key
	value
	effect
}
fragment ProviderCredentialFragment on ProviderCredential {
	id
	name
	namespace
	kind
}
fragment RevisionFragment on Revision {
	id
	sha
	git {
		ref
		folder
	}
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentExtended on ServiceDeployment {
	cluster {
		... BaseClusterFragment
	}
	errors {
		... ErrorFragment
	}
	revision {
		... RevisionFragment
	}
	... ServiceDeploymentFragment
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) UpdateServiceDeploymentWithHandle(ctx context.Context, cluster string, name string, attributes ServiceUpdateAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateServiceDeploymentWithHandle, error) {
	vars := map[string]interface{}{
		"cluster":    cluster,
		"name":       name,
		"attributes": attributes,
	}

	var res UpdateServiceDeploymentWithHandle
	if err := c.Client.Post(ctx, "UpdateServiceDeploymentWithHandle", UpdateServiceDeploymentWithHandleDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateGateDocument = `mutation updateGate ($id: ID!, $attributes: GateUpdateAttributes!) {
	updateGate(id: $id, attributes: $attributes) {
		... PipelineGateFragment
	}
}
fragment ContainerSpecFragment on ContainerSpec {
	image
	args
	env {
		name
		value
	}
	envFrom {
		configMap
		secret
	}
}
fragment GateSpecFragment on GateSpec {
	job {
		... JobSpecFragment
	}
}
fragment JobSpecFragment on JobGateSpec {
	namespace
	raw
	containers {
		... ContainerSpecFragment
	}
	labels
	annotations
	serviceAccount
}
fragment PipelineGateFragment on PipelineGate {
	id
	name
	type
	state
	updatedAt
	spec {
		... GateSpecFragment
	}
}
`

func (c *Client) UpdateGate(ctx context.Context, id string, attributes GateUpdateAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateGate, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpdateGate
	if err := c.Client.Post(ctx, "updateGate", UpdateGateDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateServiceComponentsDocument = `mutation updateServiceComponents ($id: ID!, $components: [ComponentAttributes], $errors: [ServiceErrorAttributes]) {
	updateServiceComponents(id: $id, components: $components, errors: $errors) {
		... ServiceDeploymentFragment
	}
}
fragment GitRefFragment on GitRef {
	folder
	ref
}
fragment GitRepositoryFragment on GitRepository {
	id
	error
	health
	authMethod
	url
	decrypt
}
fragment HelmSpecFragment on HelmSpec {
	valuesFiles
}
fragment KustomizeFragment on Kustomize {
	path
}
fragment ServiceDeploymentBaseFragment on ServiceDeployment {
	id
	name
	namespace
	version
	kustomize {
		... KustomizeFragment
	}
	git {
		... GitRefFragment
	}
	helm {
		... HelmSpecFragment
	}
	repository {
		... GitRepositoryFragment
	}
}
fragment ServiceDeploymentFragment on ServiceDeployment {
	... ServiceDeploymentBaseFragment
	components {
		id
		name
		group
		kind
		namespace
		state
		synced
		version
	}
	protect
	deletedAt
	sha
	tarball
	configuration {
		name
		value
	}
}
`

func (c *Client) UpdateServiceComponents(ctx context.Context, id string, components []*ComponentAttributes, errors []*ServiceErrorAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateServiceComponents, error) {
	vars := map[string]interface{}{
		"id":         id,
		"components": components,
		"errors":     errors,
	}

	var res UpdateServiceComponents
	if err := c.Client.Post(ctx, "updateServiceComponents", UpdateServiceComponentsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}
